<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Sébastien Gouëzel. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Sébastien Gouëzel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import analysis.calculus.times_cont_diff geometry.manifold.manifold</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # Smooth manifolds (possibly with boundary or corners)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  A smooth manifold is a manifold modelled on a normed vector space, or a subset like a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  half-space (to get manifolds with boundaries) for which the change of coordinates are smooth maps.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  We define a model with corners as a map `I : H → E` embedding nicely the topological space `H` in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  the vector space `E` (or more precisely as a structure containing all the relevant properties).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  Given such a model with corners `I` on `(E, H)`, we define the groupoid of local</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  homeomorphisms of `H` which are smooth when read in `E` (for any regularity `n : with_top ℕ`).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  With this groupoid at hand and the general machinery of manifolds, we thus get the notion of `C^n`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  manifold with respect to any model with corners `I` on `(E, H)`. We also introduce a specific type</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  class for `C^∞` manifolds as these are the most commonly used.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  * `model_with_corners 𝕜 E H` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    a structure containing informations on the way a space `H` embeds in a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    model vector space E over the field `𝕜`. This is all that is needed to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    define a smooth manifold with model space `H`, and model vector space `E`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  * `model_with_corners_self 𝕜 E` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    trivial model with corners structure on the space `E` embedded in itself by the identity.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  * `times_cont_diff_groupoid n I` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    when `I` is a model with corners on `(𝕜, E, H)`, this is the groupoid of local homeos of `H`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    which are of class `C^n` over the normed field `𝕜`, when read in `E`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  * `smooth_manifold_with_corners I M` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    a type class saying that the manifold `M`, modelled on the space `H`, has `C^∞` changes of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    coordinates with respect to the model with corners `I` on `(𝕜, E, H)`. This type class is just</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    a shortcut for `has_groupoid M (times_cont_diff_groupoid ⊤ I)`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  * `ext_chart_at I x`:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    in a smooth manifold with corners with the model `I` on `(E, H)`, the charts take values in `H`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    but often we may want to use their `E`-valued version, obtained by composing the charts with `I`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    Since the target is in general not open, we can not register them as local homeomorphisms, but</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    we register them as local equivs. `ext_chart_at I x` is the canonical such local equiv around `x`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  As specific examples of models with corners, we define (in the file `real_instances.lean`)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  * `euclidean_space n` for a model vector space of dimension `n`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  * `model_with_corners ℝ (euclidean_space n) (euclidean_half_space n)` for the model space used</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  to define `n`-dimensional real manifolds with boundary and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  * `model_with_corners ℝ (euclidean_space n) (euclidean_quadrant n)` for the model space used</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  to define `n`-dimensional real manifolds with corners</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  With these definitions at hand, to invoke an `n`-dimensional real manifold without boundary,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  one could use</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    `variables {n : ℕ} {M : Type*} [topological_space M] [manifold (euclidean_space n)]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54     [smooth_manifold_with_corners (model_with_corners_self ℝ (euclidean_space n)) M]`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  However, this is not the recommended way: a theorem proved using this assumption would not apply</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  for instance to the tangent space of such a manifold, which is modelled on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  `(euclidean_space n) × (euclidean_space n)` and not on `euclidean_space (2 * n)`! In the same way,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  it would not apply to product manifolds, modelled on `(euclidean_space n) × (euclidean_space m)`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  The right invocation does not focus on one specific construction, but on all constructions sharing</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  the right properties, like</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    `variables {E : Type*} [normed_group E] [normed_space ℝ E] [finite_dimensional ℝ E]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    {I : model_with_corners ℝ E E} [I.boundaryless]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    {M : Type*} [topological_space M] [manifold E M] [smooth_manifold_with_corners I M]`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  Here, `I.boundaryless` is a typeclass property ensuring that there is no boundary (this is for</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  instance the case for model_with_corners_self, or products of these). Note that one could consider</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  as a natural assumption to only use the trivial model with corners `model_with_corners_self ℝ E`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  but again in product manifolds the natural model with corners will not be this one but the product</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  one (and they are not defeq as `(λp : E × F, (p.1, p.2))` is not defeq to the identity). So, it is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  important to use the above incantation to maximize the applicability of theorems.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  We want to talk about manifolds modelled on a vector space, but also on manifolds with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  boundary, modelled on a half space (or even manifolds with corners). For the latter examples,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  we still want to define smooth functions, tangent bundles, and so on. As smooth functions are</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  well defined on vector spaces or subsets of these, one could take for model space a subtype of a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  vector space. With the drawback that the whole vector space itself (which is the most basic</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  example) is not directly a subtype of itself: the inclusion of `univ : set E` in `set E` would</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  show up in the definition, instead of `id`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  A good abstraction covering both cases it to have a vector</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  space `E` (with basic example the Euclidean space), a model space H``  (with basic example the upper</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  half space), and an embedding of `H` into `E` (which can be the identity for `H = E`, or</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  `subtype.val` for manifolds with corners). We say that the pair `(E, H)` with their embedding is a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  model with corners, and we encompass all the relevant properties (in particular the fact that the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  image of `H` in `E` should have unique differentials) in the definition of `model_with_corners`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  We concentrate on `C^∞` manifolds: all the definitions work equally well for `C^n` manifolds, but</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  later on it is a pain to carry all over the smoothness parameter, especially when one wants to deal</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  with `C^k` functions as there would be additional conditions `k ≤ n` everywhere. Since one deals</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  almost all the time with `C^∞` (or analytic) manifolds, this seems to be a reasonable choice that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  one could revisit later if needed. `C^k` manifolds are still available, but they should be called</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  using `has_groupoid M (times_cont_diff_groupoid k I)` where `I` is the model with corners.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  I have considered using the model with corners `I` as a typeclass argument, possibly `out_param`, to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  get lighter notations later on, but it did not turn out right, as on `E × F` there are two natural</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  model with corners, the trivial (identity) one, and the product one, and they are not defeq and one</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  needs to indicate to Lean which one we want to use.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  This means that when talking on objects on manifolds one will most often need to specify the model</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  with corners one is using. For instance, the tangent bundle will be `tangent_bundle I M` and the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  derivative will be `mfderiv I I&#x27; f`, instead of the more natural notations `tangent_bundle 𝕜 M` and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  `mfderiv 𝕜 f` (the field has to be explicit anyway, as some manifolds could be considered both as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  real and complex manifolds).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  universes u v w u&#x27; v&#x27; w&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  open set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  section model_with_corners</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  /-! ### Models with corners. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  /-- A structure containing informations on the way a space `H` embeds in a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  model vector space `E` over the field `𝕜`. This is all what is needed to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  define a smooth manifold with model space `H`, and model vector space `E`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  structure model_with_corners (𝕜 : Type*) [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    (E : Type*) [normed_group E] [normed_space 𝕜 E] (H : Type*) [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    extends local_equiv H E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_3 → Type u_2 → Type (max u_3 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' Local equivalence between subsets `source` and `target` of α and β respectively. The (global)
maps `to_fun : α → β` and `inv_fun : β → α` map `source` to `target` and conversely, and are inverse
to each other there. The values of `to_fun` outside of `source` and of `inv_fun` outside of `target`
are irrelevant.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  (source_eq          : source = univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), set.{u_3} α) H E to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  (unique_diff        : unique_diff_on 𝕜 (range to_fun))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='unique_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), α → β) H E to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' A property ensuring that the tangent cone to `s` at any of its points spans a dense subset of
the whole space.  The main role of this property is to ensure that the differential along `s` is
unique, hence this name. The uniqueness it asserts is proved in `unique_diff_on.eq` in
`fderiv.lean`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  (continuous_to_fun  : continuous to_fun)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), α → β) H E to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  (continuous_inv_fun : continuous inv_fun)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), β → α) H E to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  attribute [simp] model_with_corners.source_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='model_with_corners.source_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (c : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @eq.{(max (u_3+1) 1)} (@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), set.{u_3} α) H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)) (@local_equiv.source.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)) (@set.univ.{u_3} H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  /-- A vector space is a model with corners. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  def model_with_corners_self (𝕜 : Type*) [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    (E : Type*) [normed_group E] [normed_space 𝕜 E] : model_with_corners 𝕜 E E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  { to_fun     := id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    inv_fun    := id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    source     := univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    target     := univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    source_eq  := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    map_source := λ_ _, mem_univ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@set.mem.{u_2} E _x (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    map_target := λ_ _, mem_univ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@set.mem.{u_2} E _x (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    left_inv   := λ_ _, rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@set.mem.{u_2} E _x (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    right_inv  := λ_ _, rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@set.mem.{u_2} E _x (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    unique_diff := by { rw range_id, exact is_open_univ.unique_diff_on },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='set.range_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1205, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2}, @eq.{(max (u_2+1) 1)} (set.{u_2} α) (@set.range.{u_2 u_2+1} α α (@id.{u_2+1} α)) (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [t : topological_space.{u_2} α], @is_open.{u_2} α t (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='𝕜 : Type ?l_1,
_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜,
E : Type ?l_2,
_inst_2 : normed_group.{?l_2} E,
_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2
⊢ @unique_diff_on.{?l_1 ?l_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{?l_2 ?l_2+1} E E (@id.{?l_2+1} E))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type ?l_1,
_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜,
E : Type ?l_2,
_inst_2 : normed_group.{?l_2} E,
_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2
⊢ @unique_diff_on.{?l_1 ?l_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.univ.{?l_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    continuous_to_fun  := continuous_id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 654, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @continuous.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    continuous_inv_fun := continuous_id }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 654, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α], @continuous.{u_1 u_1} α α _inst_1 _inst_1 (@id.{u_1+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  /-- In the trivial model with corners, the associated local equiv is the identity. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  @[simp] lemma model_with_corners_self_local_equiv (𝕜 : Type*) [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    (E : Type*) [normed_group E] [normed_space 𝕜 E] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    (model_with_corners_self 𝕜 E).to_local_equiv = local_equiv.refl E := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='model_with_corners_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='model_with_corners.to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_2} [_inst_4 : topological_space.{u_2} H], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → local_equiv.{u_2 u_2} H E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), local_equiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A vector space is a model with corners.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The identity local equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  variables {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    {E : Type*} [normed_group E] [normed_space 𝕜 E] {H : Type*} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    (I : model_with_corners 𝕜 E H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[simp] lemma model_with_corners_target : I.target = range I.to_fun :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  by rw [← image_univ, ← local_equiv.image_source_eq_target, I.source_eq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.image_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_equiv.image_source_eq_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1213, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 158, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u_2} {ι : Type u_3} {f : ι → β}, @eq.{(max (u_2+1) 1)} (set.{u_2} β) (@set.image.{u_3 u_2} ι β f (@set.univ.{u_3} ι)) (@set.range.{u_2 u_3+1} β ι f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} {β : Type u_2} (e : local_equiv.{u_3 u_2} α β), @eq.{(max (u_2+1) 1)} (set.{u_2} β) (@set.image.{u_3 u_2} α β (@local_equiv.to_fun.{u_3 u_2} α β e) (@local_equiv.source.{u_3 u_2} α β e)) (@local_equiv.target.{u_3 u_2} α β e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_3+1) 1)} (@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), set.{u_3} α) H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@local_equiv.source.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.univ.{u_3} H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    (@set.image.{u_3 u_2} H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@set.image.{u_3 u_2} H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.source.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@set.image.{u_3 u_2} H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  @[simp] lemma model_with_corners_left_inv (x : H) : I.inv_fun (I.to_fun x) = x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  by simp [I.left_inv, I.source_eq]</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : H}, @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x (@local_equiv.source.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) → @eq.{u_3+1} H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_3+1) 1)} (@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), set.{u_3} α) H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@local_equiv.source.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.univ.{u_3} H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : H
⊢ @eq.{u_3+1} H
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : H
⊢ @eq.{u_3+1} H
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  @[simp] lemma model_with_corners_inv_fun_comp : I.inv_fun ∘ I.to_fun = id :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  by { ext x, exact model_with_corners_left_inv _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='model_with_corners_left_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 161, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) (x : H), @eq.{u_3+1} H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{u_3+1} (H → H)
    (@function.comp.{u_3+1 u_2+1 u_3+1} H E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@id.{u_3+1} H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : H
⊢ @eq.{u_3+1} H
    (@function.comp.{u_3+1 u_2+1 u_3+1} H E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       x)
    (@id.{u_3+1} H x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  @[simp] lemma model_with_corners_right_inv {x : E} (hx : x ∈ range I.to_fun) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    I.to_fun (I.inv_fun x) = x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    apply I.right_inv,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    simp [hx]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@local_equiv.target.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  lemma model_with_corners.image (s : set H) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    I.to_fun &#x27;&#x27; s = I.inv_fun ⁻¹&#x27; s ∩ range I.to_fun :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, (α → β) → set.{u_3} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@set.image.{u_3 u_2} H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       s)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    ext x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@set.image.{u_3 u_2} H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       s)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ iff
    (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
       (@set.image.{u_3 u_2} H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s))
    (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    simp only [mem_image, mem_inter_eq, mem_range, mem_preimage],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.mem_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_inter_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 897, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β) (s : set.{?l_1} α) (y : β), iff (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) y (@set.image.{?l_1 ?l_2} α β f s)) (@Exists.{?l_1+1} α (λ (x : α), and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s) (@eq.{?l_2+1} β (f x) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (x : α) (a b : set.{?l_1} α), @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) a b)) (and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x a) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {ι : Sort ?l_2} {f : ι → α} {x : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x (@set.range.{?l_1 ?l_2} α ι f)) (@Exists.{?l_2} ι (λ (y : ι), @eq.{?l_1+1} α (f y) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ iff
    (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
       (@set.image.{u_3 u_2} H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s))
    (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ iff
    (@Exists.{u_3+1} H
       (λ (x_1 : H),
          and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
            (@eq.{u_2+1} E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x_1)
               x)))
    (and
       (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x)
          s)
       (@Exists.{u_3+1} H
          (λ (y : H),
             @eq.{u_2+1} E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  y)
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ iff
    (@Exists.{u_3+1} H
       (λ (x_1 : H),
          and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
            (@eq.{u_2+1} E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x_1)
               x)))
    (and
       (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x)
          s)
       (@Exists.{u_3+1} H
          (λ (y : H),
             @eq.{u_2+1} E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  y)
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x)) →
  and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x)) →
  @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    { rintros ⟨y, ⟨ys, hy⟩⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x)) →
  and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x)) →
  @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x)) →
  and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      rw ← hy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             y))
       s)
    (@Exists.{u_3+1} H
       (λ (y_1 : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y_1)
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182      simp [ys],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ys'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             y))
       s)
    (@Exists.{u_3+1} H
       (λ (y_1 : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y_1)
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @Exists.{u_3+1} H
    (λ (y_1 : H),
       @eq.{u_2+1} E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            y_1)
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      exact ⟨y, rfl⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
ys : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @Exists.{u_3+1} H
    (λ (y_1 : H),
       @eq.{u_2+1} E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            y_1)
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x)) →
  @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    { rintros ⟨xs, ⟨y, yx⟩⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       s)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            x)) →
  @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
xs :
  @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    s,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185      rw ← yx at xs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='yx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
xs :
  @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    s,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x,
xs :
  @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))
    s
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186      simp at xs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x,
xs :
  @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))
    s
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x,
xs : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187      exact ⟨y, ⟨xs, yx⟩⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
x : E,
y : H,
yx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x,
xs : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) y s
⊢ @Exists.{u_3+1} H
    (λ (x_1 : H),
       and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x_1 s)
         (@eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               x_1)
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  /-- Given two model_with_corners `I` on `(E, H)` and `I&#x27;` on `(E&#x27;, H&#x27;)`, we define the model with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  corners `I.prod I&#x27;` on `(E × E&#x27;, H × H&#x27;)`. This appears in particular for the manifold structure on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on `(E × E, H × E)`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  def model_with_corners.prod</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    {𝕜 : Type u} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : normed_field.{u} α] [_inst_2 : normed_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    (I : model_with_corners 𝕜 E H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199    {E&#x27; : Type v&#x27;} [normed_group E&#x27;] [normed_space 𝕜 E&#x27;] {H&#x27; : Type w&#x27;} [topological_space H&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v&#x27; → Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v&#x27;) [_inst_1 : normed_field.{u} α] [_inst_2 : normed_group.{v&#x27;} β], Type (max u v&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type w&#x27; → Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    (I&#x27; : model_with_corners 𝕜 E&#x27; H&#x27;) : model_with_corners 𝕜 (E × E&#x27;) (H × H&#x27;) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v&#x27; → Type (max v v&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Type w&#x27; → Type (max w w&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  { to_fun      := λp, (I.to_fun p.1, I&#x27;.to_fun p.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='prod.{w w&#x27;} H H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} {β : Type v&#x27;}, α → β → prod.{v v&#x27;} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type v}, local_equiv.{w v} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{w w&#x27;} H H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type w&#x27;}, prod.{w w&#x27;} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w&#x27;} {β : Type v&#x27;}, local_equiv.{w&#x27; v&#x27;} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{w w&#x27;} H H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type w&#x27;}, prod.{w w&#x27;} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    inv_fun     := λp, (I.inv_fun p.1, I&#x27;.inv_fun p.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='prod.{v v&#x27;} E E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type w} {β : Type w&#x27;}, α → β → prod.{w w&#x27;} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type v}, local_equiv.{w v} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v&#x27;} E E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type v&#x27;}, prod.{v v&#x27;} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w&#x27;} {β : Type v&#x27;}, local_equiv.{w&#x27; v&#x27;} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{v v&#x27;} E E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type v&#x27;}, prod.{v v&#x27;} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    source      := (univ : set (H × H&#x27;)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Type w&#x27; → Type (max w w&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    target      := set.prod (range I.to_fun) (range I&#x27;.to_fun),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, set.{u_1} α → set.{u_2} β → set.{(max u_1 u_2)} (prod.{u_1 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type v}, local_equiv.{w v} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w&#x27;} {β : Type v&#x27;}, local_equiv.{w&#x27; v&#x27;} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205    map_source  := λ ⟨x, x&#x27;⟩ _, by simp [-mem_range, mem_range_self],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='set.mem_range_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1194, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{w w&#x27;} H H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;) (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {ι : Sort ?l_2} {f : ι → α} (i : ι), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) (f i) (@set.range.{?l_1 ?l_2} α ι f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{w w&#x27;} H H&#x27;,
_fun_match :
  ∀ (_a : prod.{w w&#x27;} H H&#x27;),
    @has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
      (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
      _a
      (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) →
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27; _a))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27; _a)))
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
x : H,
x&#x27; : H&#x27;,
_x :
  @has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
    (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
    (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)
    (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
⊢ @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206    map_target  := λ ⟨x, x&#x27;⟩ _, mem_univ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{v v&#x27;} E E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;)) (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;)) (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;) (@set.prod.{v v&#x27;} E E&#x27; (@set.range.{v w+1} E H (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27; (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    left_inv    := λ ⟨x, x&#x27;⟩ _, by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{w w&#x27;} H H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;) (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{w w&#x27;} H H&#x27;,
_fun_match :
  ∀ (_a : prod.{w w&#x27;} H H&#x27;),
    @has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
      (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
      _a
      (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;)) →
    @eq.{(max w w&#x27;)+1} (prod.{w w&#x27;} H H&#x27;)
      (@prod.mk.{w w&#x27;} H H&#x27;
         (@local_equiv.inv_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{v v&#x27;} E E&#x27;
               (@prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; _a))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; _a)))))
         (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{v v&#x27;} E E&#x27;
               (@prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; _a))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; _a))))))
      _a,
x : H,
x&#x27; : H&#x27;,
_x :
  @has_mem.mem.{(max w w&#x27;) (max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;) (set.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
    (@set.has_mem.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
    (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)
    (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
⊢ @eq.{(max w w&#x27;)+1} (prod.{w w&#x27;} H H&#x27;)
    (@prod.mk.{w w&#x27;} H H&#x27;
       (@local_equiv.inv_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{v v&#x27;} E E&#x27;
             (@prod.mk.{v v&#x27;} E E&#x27;
                (@local_equiv.to_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)))
                (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;))))))
       (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{v v&#x27;} E E&#x27;
             (@prod.mk.{v v&#x27;} E E&#x27;
                (@local_equiv.to_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)))
                (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{w w&#x27;} H H&#x27; (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)))))))
    (@prod.mk.{w w&#x27;} H H&#x27; x x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208    right_inv   := λ ⟨x, x&#x27;⟩ ⟨hx, hx&#x27;⟩, by rw [I.right_inv, I&#x27;.right_inv]; rwa model_with_corners_target,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='model_with_corners_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 158, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{v v&#x27;} E E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;)) (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;)) (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;) (@set.prod.{v v&#x27;} E E&#x27; (@set.range.{v w+1} E H (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27; (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : E}, @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) x (@local_equiv.target.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) → @eq.{v+1} E (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@local_equiv.inv_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {x : E&#x27;}, @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) x (@local_equiv.target.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)) → @eq.{v&#x27;+1} E&#x27; (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;) (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v&#x27;} [_inst_2 : normed_group.{v&#x27;} E] [_inst_3 : @normed_space.{u v&#x27;} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w&#x27;} [_inst_4 : topological_space.{w&#x27;} H] (I : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @eq.{(max (v&#x27;+1) 1)} (set.{v&#x27;} E) (@local_equiv.target.{w&#x27; v&#x27;} H E (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.range.{v&#x27; w&#x27;+1} E H (@local_equiv.to_fun.{w&#x27; v&#x27;} H E (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27; (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)

𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@local_equiv.target.{w v} H E
       (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@local_equiv.target.{w&#x27; v&#x27;} H&#x27; E&#x27;
       (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))

𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@local_equiv.target.{w v} H E
       (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
_x : prod.{v v&#x27;} E E&#x27;,
_fun_match :
  ∀ (_a : prod.{v v&#x27;} E E&#x27;),
    @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
      _a
      (@set.prod.{v v&#x27;} E E&#x27;
         (@set.range.{v w+1} E H
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
    @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
      (@prod.mk.{v v&#x27;} E E&#x27;
         (@local_equiv.to_fun.{w v} H E
            (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@prod.fst.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a)))))
         (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
            (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
            (@prod.snd.{w w&#x27;} H H&#x27;
               (@prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; _a))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; _a))))))
      _a,
x : E,
x&#x27; : E&#x27;,
_x :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))),
_fun_match :
  @has_mem.mem.{(max v v&#x27;) (max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;) (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.has_mem.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))) →
  @eq.{(max v v&#x27;)+1} (prod.{v v&#x27;} E E&#x27;)
    (@prod.mk.{v v&#x27;} E E&#x27;
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@prod.fst.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))))))
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
          (@prod.snd.{w w&#x27;} H H&#x27;
             (@prod.mk.{w w&#x27;} H H&#x27;
                (@local_equiv.inv_fun.{w v} H E
                   (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                   (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))
                (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                   (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                   (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;)))))))
    (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;),
hx :
  @has_mem.mem.{v v} E (set.{v} E) (@set.has_mem.{v} E) (@prod.fst.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v w+1} E H
       (@local_equiv.to_fun.{w v} H E
          (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx&#x27; :
  @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
       (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
          (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)))
⊢ @has_mem.mem.{v&#x27; v&#x27;} E&#x27; (set.{v&#x27;} E&#x27;) (@set.has_mem.{v&#x27;} E&#x27;) (@prod.snd.{v v&#x27;} E E&#x27; (@prod.mk.{v v&#x27;} E E&#x27; x x&#x27;))
    (@local_equiv.target.{w&#x27; v&#x27;} H&#x27; E&#x27;
       (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    source_eq   := rfl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    unique_diff := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@local_equiv.mk.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
             (λ (p : prod.{w w&#x27;} H H&#x27;),
                @prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; p))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; p)))
             (λ (p : prod.{v v&#x27;} E E&#x27;),
                @prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; p))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; p)))
             (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
             (@set.prod.{v v&#x27;} E E&#x27;
                (@set.range.{v w+1} E H
                   (@local_equiv.to_fun.{w v} H E
                      (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
                (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
                   (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                      (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_1.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_2.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_3.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_5.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211      have : range (λ(p : H × H&#x27;), (I.to_fun p.1, I&#x27;.to_fun p.2)) = set.prod (range I.to_fun) (range I&#x27;.to_fun),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w → Type w&#x27; → Type (max w w&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type v&#x27;}, α → β → prod.{v v&#x27;} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max v v&#x27;)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type v&#x27;}, set.{v} α → set.{v&#x27;} β → set.{(max v v&#x27;)} (prod.{v v&#x27;} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max v v&#x27;)} {ι : Type (max w w&#x27;)}, (ι → α) → set.{(max v v&#x27;)} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@local_equiv.mk.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
             (λ (p : prod.{w w&#x27;} H H&#x27;),
                @prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; p))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; p)))
             (λ (p : prod.{v v&#x27;} E E&#x27;),
                @prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; p))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; p)))
             (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
             (@set.prod.{v v&#x27;} E E&#x27;
                (@set.range.{v w+1} E H
                   (@local_equiv.to_fun.{w v} H E
                      (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
                (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
                   (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                      (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_1.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_2.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_3.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_5.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212        by { rw ← prod_range_range_eq },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.prod_range_range_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1464, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type w&#x27;} {γ : Type v} {δ : Type v&#x27;} {m₁ : α → γ} {m₂ : β → δ}, @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} γ δ)) (@set.prod.{v v&#x27;} γ δ (@set.range.{v w+1} γ α m₁) (@set.range.{v&#x27; w&#x27;+1} δ β m₂)) (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} γ δ) (prod.{w w&#x27;} α β) (λ (p : prod.{w w&#x27;} α β), @prod.mk.{v v&#x27;} γ δ (m₁ (@prod.fst.{w w&#x27;} α β p)) (m₂ (@prod.snd.{w w&#x27;} α β p))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='2 goals
𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))

𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
this :
  @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@local_equiv.mk.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
             (λ (p : prod.{w w&#x27;} H H&#x27;),
                @prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; p))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; p)))
             (λ (p : prod.{v v&#x27;} E E&#x27;),
                @prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; p))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; p)))
             (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
             (@set.prod.{v v&#x27;} E E&#x27;
                (@set.range.{v w+1} E H
                   (@local_equiv.to_fun.{w v} H E
                      (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
                (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
                   (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                      (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_1.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_2.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_3.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_5.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
this :
  @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@local_equiv.mk.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
             (λ (p : prod.{w w&#x27;} H H&#x27;),
                @prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; p))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; p)))
             (λ (p : prod.{v v&#x27;} E E&#x27;),
                @prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; p))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; p)))
             (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
             (@set.prod.{v v&#x27;} E E&#x27;
                (@set.range.{v w+1} E H
                   (@local_equiv.to_fun.{w v} H E
                      (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
                (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
                   (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                      (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_1.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_2.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_3.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_5.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;)) (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;) (λ (p : prod.{w w&#x27;} H H&#x27;), @prod.mk.{v v&#x27;} E E&#x27; (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@prod.fst.{w w&#x27;} H H&#x27; p)) (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;) (@prod.snd.{w w&#x27;} H H&#x27; p)))) (@set.prod.{v v&#x27;} E E&#x27; (@set.range.{v w+1} E H (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27; (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27; (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
this :
  @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@local_equiv.mk.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
             (λ (p : prod.{w w&#x27;} H H&#x27;),
                @prod.mk.{v v&#x27;} E E&#x27;
                  (@local_equiv.to_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{w w&#x27;} H H&#x27; p))
                  (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{w w&#x27;} H H&#x27; p)))
             (λ (p : prod.{v v&#x27;} E E&#x27;),
                @prod.mk.{w w&#x27;} H H&#x27;
                  (@local_equiv.inv_fun.{w v} H E
                     (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     (@prod.fst.{v v&#x27;} E E&#x27; p))
                  (@local_equiv.inv_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                     (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
                     (@prod.snd.{v v&#x27;} E E&#x27; p)))
             (@set.univ.{(max w w&#x27;)} (prod.{w w&#x27;} H H&#x27;))
             (@set.prod.{v v&#x27;} E E&#x27;
                (@set.range.{v w+1} E H
                   (@local_equiv.to_fun.{w v} H E
                      (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
                (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
                   (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
                      (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_1.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_2.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{w w&#x27;} H H&#x27;),
                @model_with_corners.prod._match_3.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x)
             (λ (_x : prod.{v v&#x27;} E E&#x27;),
                @model_with_corners.prod._match_5.{u v v&#x27; w w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_5
                  _inst_6
                  H&#x27;
                  _inst_7
                  I&#x27;
                  _x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
this :
  @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214      exact unique_diff_on.prod I.unique_diff I&#x27;.unique_diff,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='unique_diff_on.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {F : Type v&#x27;} [_inst_4 : normed_group.{v&#x27;} F] [_inst_5 : @normed_space.{u v&#x27;} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_4] {s : set.{v} E} {t : set.{v&#x27;} F}, @unique_diff_on.{u v} 𝕜 _inst_1 E _inst_2 _inst_3 s → @unique_diff_on.{u v&#x27;} 𝕜 _inst_1 F _inst_4 _inst_5 t → @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E F) (@prod.normed_group.{v v&#x27;} E F _inst_2 _inst_4) (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E F _inst_2 _inst_3 _inst_4 _inst_5) (@set.prod.{v v&#x27;} E F s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The product of two sets of unique differentiability is a set of unique differentiability.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
E&#x27; : Type v&#x27;,
_inst_5 : normed_group.{v&#x27;} E&#x27;,
_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5,
H&#x27; : Type w&#x27;,
_inst_7 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7,
this :
  @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))
⊢ @unique_diff_on.{u (max v v&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_5
       _inst_6)
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 I&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    continuous_to_fun := (continuous.comp I.continuous_to_fun continuous_fst).prod_mk</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.continuous_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β}, @continuous.{u_2 u_3} β γ _inst_2 _inst_3 g → @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H] (c : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @continuous.{w v} H E _inst_4 (@uniform_space.to_topological_space.{v} E (@metric_space.to_uniform_space&#x27;.{v} E (@normed_group.to_metric_space.{v} E _inst_2))) (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β], @continuous.{(max u v) u} (prod.{u v} α β) α (@prod.topological_space.{u v} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {β : Type v&#x27;} {γ : Type (max w w&#x27;)} [_inst_1 : topological_space.{v} α] [_inst_2 : topological_space.{v&#x27;} β] [_inst_3 : topological_space.{(max w w&#x27;)} γ] {f : γ → α} {g : γ → β}, @continuous.{(max w w&#x27;) v} γ α _inst_3 _inst_1 f → @continuous.{(max w w&#x27;) v&#x27;} γ β _inst_3 _inst_2 g → @continuous.{(max w w&#x27;) (max v v&#x27;)} γ (prod.{v v&#x27;} α β) _inst_3 (@prod.topological_space.{v v&#x27;} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{v v&#x27;} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217      (continuous.comp I&#x27;.continuous_to_fun continuous_snd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.continuous_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β}, @continuous.{u_2 u_3} β γ _inst_2 _inst_3 g → @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v&#x27;} [_inst_2 : normed_group.{v&#x27;} E] [_inst_3 : @normed_space.{u v&#x27;} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w&#x27;} [_inst_4 : topological_space.{w&#x27;} H] (c : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @continuous.{w&#x27; v&#x27;} H E _inst_4 (@uniform_space.to_topological_space.{v&#x27;} E (@metric_space.to_uniform_space&#x27;.{v&#x27;} E (@normed_group.to_metric_space.{v&#x27;} E _inst_2))) (@local_equiv.to_fun.{w&#x27; v&#x27;} H E (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β], @continuous.{(max u v) v} (prod.{u v} α β) β (@prod.topological_space.{u v} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    continuous_inv_fun := (continuous.comp I.continuous_inv_fun continuous_fst).prod_mk</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.continuous_inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β}, @continuous.{u_2 u_3} β γ _inst_2 _inst_3 g → @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H] (c : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @continuous.{v w} E H (@uniform_space.to_topological_space.{v} E (@metric_space.to_uniform_space&#x27;.{v} E (@normed_group.to_metric_space.{v} E _inst_2))) _inst_4 (@local_equiv.inv_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β], @continuous.{(max u v) u} (prod.{u v} α β) α (@prod.topological_space.{u v} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type w} {β : Type w&#x27;} {γ : Type (max v v&#x27;)} [_inst_1 : topological_space.{w} α] [_inst_2 : topological_space.{w&#x27;} β] [_inst_3 : topological_space.{(max v v&#x27;)} γ] {f : γ → α} {g : γ → β}, @continuous.{(max v v&#x27;) w} γ α _inst_3 _inst_1 f → @continuous.{(max v v&#x27;) w&#x27;} γ β _inst_3 _inst_2 g → @continuous.{(max v v&#x27;) (max w w&#x27;)} γ (prod.{w w&#x27;} α β) _inst_3 (@prod.topological_space.{w w&#x27;} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{w w&#x27;} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219      (continuous.comp I&#x27;.continuous_inv_fun continuous_snd) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.continuous_inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β}, @continuous.{u_2 u_3} β γ _inst_2 _inst_3 g → @continuous.{u_1 u_2} α β _inst_1 _inst_2 f → @continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v&#x27;} [_inst_2 : normed_group.{v&#x27;} E] [_inst_3 : @normed_space.{u v&#x27;} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w&#x27;} [_inst_4 : topological_space.{w&#x27;} H] (c : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @continuous.{v&#x27; w&#x27;} E H (@uniform_space.to_topological_space.{v&#x27;} E (@metric_space.to_uniform_space&#x27;.{v&#x27;} E (@normed_group.to_metric_space.{v&#x27;} E _inst_2))) _inst_4 (@local_equiv.inv_fun.{w&#x27; v&#x27;} H E (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{v} β], @continuous.{(max u v) v} (prod.{u v} α β) β (@prod.topological_space.{u v} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  /-- Special case of product model with corners, which is trivial on the second factor. This shows up</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  as the model to tangent bundles. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  @[reducible] def model_with_corners.tangent</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    {𝕜 : Type u} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225    {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : normed_field.{u} α] [_inst_2 : normed_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    (I : model_with_corners 𝕜 E H) : model_with_corners 𝕜 (E × E) (H × E) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Type v → Type (max w v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227   I.prod (model_with_corners_self 𝕜 E)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='model_with_corners_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 195, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H], @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {E&#x27; : Type v} [_inst_5 : normed_group.{v} E&#x27;] [_inst_6 : @normed_space.{u v} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5] {H&#x27; : Type v} [_inst_7 : topological_space.{v} H&#x27;], @model_with_corners.{u v v} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 → @model_with_corners.{u v (max w v)} 𝕜 _inst_1 (prod.{v v} E E&#x27;) (@prod.normed_group.{v v} E E&#x27; _inst_2 _inst_5) (@prod.normed_space.{u v v} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3 _inst_5 _inst_6) (prod.{w v} H H&#x27;) (@prod.topological_space.{w v} H H&#x27; _inst_4 _inst_7)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Given two model_with_corners `I` on `(E, H)` and `I&#x27;` on `(E&#x27;, H&#x27;)`, we define the model with
corners `I.prod I&#x27;` on `(E × E&#x27;, H × H&#x27;)`. This appears in particular for the manifold structure on
the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on `(E × E, H × E)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A vector space is a model with corners.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  section boundaryless</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  /-- Property ensuring that the model with corners `I` defines manifolds without boundary. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  class model_with_corners.boundaryless {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    {E : Type*} [normed_group E] [normed_space 𝕜 E] {H : Type*} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    (I : model_with_corners 𝕜 E H) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  (range_eq_univ : range I.to_fun = univ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  /-- The trivial model with corners has no boundary -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  instance model_with_corners_self_range (𝕜 : Type*) [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    (E : Type*) [normed_group E] [normed_space 𝕜 E] : (model_with_corners_self 𝕜 E).boundaryless :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='model_with_corners_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='model_with_corners.boundaryless'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_2} [_inst_4 : topological_space.{u_2} H], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A vector space is a model with corners.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Property ensuring that the model with corners `I` defines manifolds without boundary.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  ⟨by simp⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='𝕜 : Type ?l_1,
_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜,
E : Type ?l_2,
_inst_2 : normed_group.{?l_2} E,
_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2
⊢ @eq.{(max (?l_2+1) 1)} (set.{?l_2} E)
    (@set.range.{?l_2 ?l_2+1} E E
       (@local_equiv.to_fun.{?l_2 ?l_2} E E
          (@model_with_corners.to_local_equiv.{?l_1 ?l_2 ?l_2} 𝕜 _inst_1 E _inst_2 _inst_3 E
             (@uniform_space.to_topological_space.{?l_2} E
                (@metric_space.to_uniform_space&#x27;.{?l_2} E (@normed_group.to_metric_space.{?l_2} E _inst_2)))
             (@model_with_corners_self.{?l_1 ?l_2} 𝕜 _inst_1 E _inst_2 _inst_3))))
    (@set.univ.{?l_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  /-- If two model with corners are boundaryless, their product also is -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  instance model_with_corners.range_eq_univ_prod {𝕜 : Type u} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    {E : Type v} [normed_group E] [normed_space 𝕜 E] {H : Type w} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v) [_inst_1 : normed_field.{u} α] [_inst_2 : normed_group.{v} β], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245    (I : model_with_corners 𝕜 E H) [I.boundaryless]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.boundaryless'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H], @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Property ensuring that the model with corners `I` defines manifolds without boundary.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    {E&#x27; : Type v&#x27;} [normed_group E&#x27;] [normed_space 𝕜 E&#x27;] {H&#x27; : Type w&#x27;} [topological_space H&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v&#x27; → Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) (β : Type v&#x27;) [_inst_1 : normed_field.{u} α] [_inst_2 : normed_group.{v&#x27;} β], Type (max u v&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type w&#x27; → Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    (I&#x27; : model_with_corners 𝕜 E&#x27; H&#x27;) [I&#x27;.boundaryless] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.boundaryless'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v&#x27;} [_inst_2 : normed_group.{v&#x27;} E] [_inst_3 : @normed_space.{u v&#x27;} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w&#x27;} [_inst_4 : topological_space.{w&#x27;} H], @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Property ensuring that the model with corners `I` defines manifolds without boundary.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    (I.prod I&#x27;).boundaryless :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='model_with_corners.boundaryless'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 195, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H], @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {E&#x27; : Type v&#x27;} [_inst_5 : normed_group.{v&#x27;} E&#x27;] [_inst_6 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_5] {H&#x27; : Type w&#x27;} [_inst_7 : topological_space.{w&#x27;} H&#x27;], @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 → @model_with_corners.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;) (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_5) (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3 _inst_5 _inst_6) (prod.{w w&#x27;} H H&#x27;) (@prod.topological_space.{w w&#x27;} H H&#x27; _inst_4 _inst_7)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type (max v v&#x27;)} [_inst_2 : normed_group.{(max v v&#x27;)} E] [_inst_3 : @normed_space.{u (max v v&#x27;)} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type (max w w&#x27;)} [_inst_4 : topological_space.{(max w w&#x27;)} H], @model_with_corners.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Given two model_with_corners `I` on `(E, H)` and `I&#x27;` on `(E&#x27;, H&#x27;)`, we define the model with
corners `I.prod I&#x27;` on `(E × E&#x27;, H × H&#x27;)`. This appears in particular for the manifold structure on
the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on `(E × E, H × E)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Property ensuring that the model with corners `I` defines manifolds without boundary.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @model_with_corners.boundaryless.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;)
    (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_6)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_6
       _inst_7)
    (prod.{w w&#x27;} H H&#x27;)
    (@prod.topological_space.{w w&#x27;} H H&#x27; _inst_4 _inst_8)
    (@model_with_corners.prod.{u v w v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @model_with_corners.boundaryless.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;)
    (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_6)
    (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3
       _inst_6
       _inst_7)
    (prod.{w w&#x27;} H H&#x27;)
    (@prod.topological_space.{w w&#x27;} H H&#x27; _inst_4 _inst_8)
    (@model_with_corners.prod.{u v w v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@model_with_corners.to_local_equiv.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;)
             (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_6)
             (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2
                _inst_3
                _inst_6
                _inst_7)
             (prod.{w w&#x27;} H H&#x27;)
             (@prod.topological_space.{w w&#x27;} H H&#x27; _inst_4 _inst_8)
             (@model_with_corners.prod.{u v w v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_6 _inst_7 H&#x27;
                _inst_8
                I&#x27;))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    dsimp [model_with_corners.prod],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='model_with_corners.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 195, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {E&#x27; : Type ?l_4} [_inst_5 : normed_group.{?l_4} E&#x27;] [_inst_6 : @normed_space.{?l_1 ?l_4} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_5] {H&#x27; : Type ?l_5} [_inst_7 : topological_space.{?l_5} H&#x27;], @model_with_corners.{?l_1 ?l_4 ?l_5} 𝕜 _inst_1 E&#x27; _inst_5 _inst_6 H&#x27; _inst_7 → @model_with_corners.{?l_1 (max ?l_2 ?l_4) (max ?l_3 ?l_5)} 𝕜 _inst_1 (prod.{?l_2 ?l_4} E E&#x27;) (@prod.normed_group.{?l_2 ?l_4} E E&#x27; _inst_2 _inst_5) (@prod.normed_space.{?l_1 ?l_2 ?l_4} 𝕜 (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) E E&#x27; _inst_2 _inst_3 _inst_5 _inst_6) (prod.{?l_3 ?l_5} H H&#x27;) (@prod.topological_space.{?l_3 ?l_5} H H&#x27; _inst_4 _inst_7)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given two model_with_corners `I` on `(E, H)` and `I&#x27;` on `(E&#x27;, H&#x27;)`, we define the model with
corners `I.prod I&#x27;` on `(E × E&#x27;, H × H&#x27;)`. This appears in particular for the manifold structure on
the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on `(E × E, H × E)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (@local_equiv.to_fun.{(max w w&#x27;) (max v v&#x27;)} (prod.{w w&#x27;} H H&#x27;) (prod.{v v&#x27;} E E&#x27;)
          (@model_with_corners.to_local_equiv.{u (max v v&#x27;) (max w w&#x27;)} 𝕜 _inst_1 (prod.{v v&#x27;} E E&#x27;)
             (@prod.normed_group.{v v&#x27;} E E&#x27; _inst_2 _inst_6)
             (@prod.normed_space.{u v v&#x27;} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) E E&#x27; _inst_2
                _inst_3
                _inst_6
                _inst_7)
             (prod.{w w&#x27;} H H&#x27;)
             (@prod.topological_space.{w w&#x27;} H H&#x27; _inst_4 _inst_8)
             (@model_with_corners.prod.{u v w v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I E&#x27; _inst_6 _inst_7 H&#x27;
                _inst_8
                I&#x27;))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    rw [← prod_range_range_eq, model_with_corners.boundaryless.range_eq_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.prod_range_range_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='model_with_corners.boundaryless.range_eq_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1464, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type w} {β : Type w&#x27;} {γ : Type v} {δ : Type v&#x27;} {m₁ : α → γ} {m₂ : β → δ}, @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} γ δ)) (@set.prod.{v v&#x27;} γ δ (@set.range.{v w+1} γ α m₁) (@set.range.{v&#x27; w&#x27;+1} δ β m₂)) (@set.range.{(max v v&#x27;) (max (w+1) (w&#x27;+1))} (prod.{v v&#x27;} γ δ) (prod.{w w&#x27;} α β) (λ (p : prod.{w w&#x27;} α β), @prod.mk.{v v&#x27;} γ δ (m₁ (@prod.fst.{w w&#x27;} α β p)) (m₂ (@prod.snd.{w w&#x27;} α β p))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v} [_inst_2 : normed_group.{v} E] [_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w} [_inst_4 : topological_space.{w} H] (I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) [c : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I], @eq.{(max (v+1) 1)} (set.{v} E) (@set.range.{v w+1} E H (@local_equiv.to_fun.{w v} H E (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@set.univ.{v} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.prod.{v v&#x27;} E E&#x27;
       (@set.range.{v w+1} E H
          (@local_equiv.to_fun.{w v} H E
             (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.prod.{v v&#x27;} E E&#x27; (@set.univ.{v} E)
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253        model_with_corners.boundaryless.range_eq_univ, univ_prod_univ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='model_with_corners.boundaryless.range_eq_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ_prod_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1499, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {E : Type v&#x27;} [_inst_2 : normed_group.{v&#x27;} E] [_inst_3 : @normed_space.{u v&#x27;} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2] {H : Type w&#x27;} [_inst_4 : topological_space.{w&#x27;} H] (I : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) [c : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I], @eq.{(max (v&#x27;+1) 1)} (set.{v&#x27;} E) (@set.range.{v&#x27; w&#x27;+1} E H (@local_equiv.to_fun.{w&#x27; v&#x27;} H E (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@set.univ.{v&#x27;} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type v&#x27;}, @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} α β)) (@set.prod.{v v&#x27;} α β (@set.univ.{v} α) (@set.univ.{v&#x27;} β)) (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} α β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.prod.{v v&#x27;} E E&#x27; (@set.univ.{v} E)
       (@set.range.{v&#x27; w&#x27;+1} E&#x27; H&#x27;
          (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
             (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.prod.{v v&#x27;} E E&#x27; (@set.univ.{v} E) (@set.univ.{v&#x27;} E&#x27;))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u,
_inst_1 : nondiscrete_normed_field.{u} 𝕜,
E : Type v,
_inst_2 : normed_group.{v} E,
_inst_3 : @normed_space.{u v} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2,
H : Type w,
_inst_4 : topological_space.{w} H,
I : @model_with_corners.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
_inst_5 : @model_with_corners.boundaryless.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I,
E&#x27; : Type v&#x27;,
_inst_6 : normed_group.{v&#x27;} E&#x27;,
_inst_7 : @normed_space.{u v&#x27;} 𝕜 E&#x27; (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_6,
H&#x27; : Type w&#x27;,
_inst_8 : topological_space.{w&#x27;} H&#x27;,
I&#x27; : @model_with_corners.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8,
_inst_9 : @model_with_corners.boundaryless.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;
⊢ @eq.{(max ((max v v&#x27;)+1) 1)} (set.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))
    (@set.range.{(max v v&#x27;) (max w w&#x27;)+1} (prod.{v v&#x27;} E E&#x27;) (prod.{w w&#x27;} H H&#x27;)
       (λ (p : prod.{w w&#x27;} H H&#x27;),
          @prod.mk.{v v&#x27;} E E&#x27;
            (@local_equiv.to_fun.{w v} H E
               (@model_with_corners.to_local_equiv.{u v w} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (@prod.fst.{w w&#x27;} H H&#x27; p))
            (@local_equiv.to_fun.{w&#x27; v&#x27;} H&#x27; E&#x27;
               (@model_with_corners.to_local_equiv.{u v&#x27; w&#x27;} 𝕜 _inst_1 E&#x27; _inst_6 _inst_7 H&#x27; _inst_8 I&#x27;)
               (@prod.snd.{w w&#x27;} H H&#x27; p))))
    (@set.univ.{(max v v&#x27;)} (prod.{v v&#x27;} E E&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  end boundaryless</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  section times_cont_diff_groupoid</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  /-! ### Smooth functions on models with corners -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  variables {m n : with_top ℕ} {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  {E : Type*} [normed_group E] [normed_space 𝕜 E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  {H : Type*} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  (I : model_with_corners 𝕜 E H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  {M : Type*} [topological_space M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  variable (n)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  /-- Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  the maps that are `C^n` when read in `E` through `I`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  def times_cont_diff_groupoid : structure_groupoid H :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='structure_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π (H : Type u) [_inst_1 : topological_space.{u} H], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title=' A structure groupoid is a set of local homeomorphisms of a topological space stable under
composition and inverse. They appear in the definition of the smoothness class of a manifold.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  pregroupoid.groupoid</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pregroupoid.groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {H : Type u} [_inst_1 : topological_space.{u} H], @pregroupoid.{u} H _inst_1 → @structure_groupoid.{u} H _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Construct a groupoid of local homeos for which the map and its inverse have some property,
from a pregroupoid asserting that this property is stable under composition.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  { property := λf s, times_cont_diff_on 𝕜 n (I.to_fun ∘ f ∘ I.inv_fun) (I.inv_fun ⁻¹&#x27; s ∩ range I.to_fun),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (𝕜 : Type w) [_inst_8 : nondiscrete_normed_field.{w} 𝕜], with_top.{0} nat → Π {E F : Type u} [_inst_9 : normed_group.{u} E] [_inst_10 : @normed_space.{w u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{w} 𝕜 _inst_8) _inst_9] [_inst_11 : normed_group.{u} F] [_inst_12 : @normed_space.{w u} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{w} 𝕜 _inst_8) _inst_11], (E → F) → set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3} {φ : Type u_2}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A function is `C^n` on a set, for `n : with_top ℕ`, if its derivatives of order at most `n`
are all well defined and continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273    comp     := λf g u v hf hg huv, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='huv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) u) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) v) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u_3} H _inst_4 (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274      have A : unique_diff_on 𝕜 (I.inv_fun ⁻¹&#x27; (u ∩ (f ⁻¹&#x27; v)) ∩ range (I.to_fun)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='unique_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A property ensuring that the tangent cone to `s` at any of its points spans a dense subset of
the whole space.  The main role of this property is to ensure that the differential along `s` is
unique, hence this name. The uniqueness it asserts is proved in `unique_diff_on.eq` in
`fderiv.lean`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275        by { rw inter_comm, exact I.unique_diff.inter (I.continuous_inv_fun _ huv) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='model_with_corners.unique_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='huv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (c : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_3} H _inst_4 (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276      have : I.to_fun ∘ (g ∘ f) ∘ I.inv_fun = (I.to_fun ∘ g ∘ I.inv_fun) ∘ (I.to_fun ∘ f ∘ I.inv_fun),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3} {φ : Type u_2}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277        by { ext x, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       x)
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (E → E) (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f) (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@function.comp.{u_2+1 u_2+1 u_2+1} E E E (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      apply times_cont_diff_on.comp hg _ A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='times_cont_diff_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 761, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_2} [_inst_4 : normed_group.{u_2} F] [_inst_5 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4] {G : Type u_2} [_inst_6 : normed_group.{u_2} G] [_inst_7 : @normed_space.{u_1 u_2} 𝕜 G (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_6] {n : with_top.{0} nat} {s : set.{u_2} E} {t : set.{u_2} F} {g : F → G} {f : E → F}, @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n F G _inst_4 _inst_5 _inst_6 _inst_7 g t → @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f s → @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 s → @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E) s (@set.preimage.{u_2 u_2} E F f t) → @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E G _inst_2 _inst_3 _inst_6 _inst_7 (@function.comp.{u_2+1 u_2+1 u_2+1} E F G g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) v) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The composition of `C^n` functions on domains is `C^n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@set.preimage.{u_2 u_2} E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280      { rintros x ⟨hx1, hx2⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@set.preimage.{u_2 u_2} E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@set.preimage.{u_2 u_2} E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_2} E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281        simp at ⊢ hx1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_2} E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx1 :
  and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       u)
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x))
       v)
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x))
       v)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282        exact ⟨hx1.2, (f (I.inv_fun x)), rfl⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hx1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x) u) (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) (f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x)) v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
hx1 :
  and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x)
       u)
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x))
       v)
⊢ and
    (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
       (f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             x))
       v)
    (@Exists.{u_3+1} H
       (λ (y : H),
          @eq.{u_2+1} E
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               y)
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
               (f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                     x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283      { refine hf.mono _ A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) u) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284        rintros x ⟨hx1, hx2⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285        exact ⟨hx1.1, hx2⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hx1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hx2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u v : set.{u_3} H,
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
hg :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
huv :
  @is_open.{u_3} H _inst_4
    (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)),
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (E → E)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@function.comp.{u_3+1 u_3+1 u_3+1} H H H g f)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@function.comp.{u_2+1 u_2+1 u_2+1} E E E
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u (@set.preimage.{u_3 u_3} H H f v))),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287    id_mem   := begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288      have A : unique_diff_on 𝕜 ((I.inv_fun ⁻¹&#x27; univ) ∩ (range I.to_fun)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='unique_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A property ensuring that the tangent cone to `s` at any of its points spans a dense subset of
the whole space.  The main role of this property is to ensure that the differential along `s` is
unique, hence this name. The uniqueness it asserts is proved in `unique_diff_on.eq` in
`fderiv.lean`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289        by simp [I.unique_diff],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290      apply times_cont_diff_on.congr (times_cont_diff_id.times_cont_diff_on A) A _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='times_cont_diff_on.congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 518, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 669, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_2} [_inst_4 : normed_group.{u_2} F] [_inst_5 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4] {f f₁ : E → F} {n : with_top.{0} nat} {s : set.{u_2} E}, @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f s → @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 s → (∀ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s → @eq.{u_2+1} F (f₁ x) (f x)) → @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f₁ s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {n : with_top.{0} nat}, @times_cont_diff.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.univ.{u_3} H)) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The identity is C^∞.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            (@set.univ.{u_3} H))
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291      rintros x ⟨hx1, hx2⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            (@set.univ.{u_3} H))
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292      rcases mem_range.1 hx2 with ⟨y, hy⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hx2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {ι : Type u_3} {f : ι → α} {x : α}, iff (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x (@set.range.{u_2 u_3+1} α ι f)) (@Exists.{u_3+1} ι (λ (y : ι), @eq.{u_2+1} α (f y) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
y : H,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293      rw ← hy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) y) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
y : H,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
y : H,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))
    (@id.{u_2+1} E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294      simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
A :
  @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@set.univ.{u_3} H))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
x : E,
hx1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.univ.{u_3} H)),
hx2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
y : H,
hy :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       y)
    x
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H (@id.{u_3+1} H)
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))
    (@id.{u_2+1} E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296    locality := λf u hu H, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u_3} H _inst_4 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @Exists.{(max (u_3+1) 1)} (set.{u_3} H) (λ (v : set.{u_3} H), and (@is_open.{u_3} H _inst_4 v) (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v) (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v)) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297      apply times_cont_diff_on_of_locally_times_cont_diff_on,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='times_cont_diff_on_of_locally_times_cont_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_2} [_inst_4 : normed_group.{u_2} F] [_inst_5 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4] {f : E → F} {n : with_top.{0} nat} {s : set.{u_2} E}, @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 s → (∀ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s → @Exists.{(max (u_2+1) 1)} (set.{u_2} E) (λ (u : set.{u_2} E), and (@is_open.{u_2} E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) u) (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u) (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) s u))))) → @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Being `C^n` is a local property.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
      (λ (u_1 : set.{u_2} E),
         and
           (@is_open.{u_2} E
              (@uniform_space.to_topological_space.{u_2} E
                 (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
              u_1)
           (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u_1)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                       (@set.preimage.{u_2 u_3} E H
                          (@local_equiv.inv_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))
                          u)
                       (@set.range.{u_2 u_3+1} E H
                          (@local_equiv.to_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))))
                    u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298      show unique_diff_on 𝕜 ((I.inv_fun ⁻¹&#x27; u) ∩ (range (I.to_fun))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='unique_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A property ensuring that the tangent cone to `s` at any of its points spans a dense subset of
the whole space.  The main role of this property is to ensure that the differential along `s` is
unique, hence this name. The uniqueness it asserts is proved in `unique_diff_on.eq` in
`fderiv.lean`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
      (λ (u_1 : set.{u_2} E),
         and
           (@is_open.{u_2} E
              (@uniform_space.to_topological_space.{u_2} E
                 (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
              u_1)
           (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u_1)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                       (@set.preimage.{u_2 u_3} E H
                          (@local_equiv.inv_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))
                          u)
                       (@set.range.{u_2 u_3+1} E H
                          (@local_equiv.to_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))))
                    u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299        by { rw inter_comm, exact I.unique_diff.inter (I.continuous_inv_fun _ hu) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='model_with_corners.unique_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (c : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_3} H _inst_4 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
      (λ (u_1 : set.{u_2} E),
         and
           (@is_open.{u_2} E
              (@uniform_space.to_topological_space.{u_2} E
                 (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
              u_1)
           (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u_1)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                       (@set.preimage.{u_2 u_3} E H
                          (@local_equiv.inv_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))
                          u)
                       (@set.range.{u_2 u_3+1} E H
                          (@local_equiv.to_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))))
                    u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
      (λ (u_1 : set.{u_2} E),
         and
           (@is_open.{u_2} E
              (@uniform_space.to_topological_space.{u_2} E
                 (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
              u_1)
           (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u_1)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                       (@set.preimage.{u_2 u_3} E H
                          (@local_equiv.inv_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))
                          u)
                       (@set.range.{u_2 u_3+1} E H
                          (@local_equiv.to_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))))
                    u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300      rintros y ⟨hy1, hy2⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I)))))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
      (λ (u_1 : set.{u_2} E),
         and
           (@is_open.{u_2} E
              (@uniform_space.to_topological_space.{u_2} E
                 (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
              u_1)
           (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x u_1)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                       (@set.preimage.{u_2 u_3} E H
                          (@local_equiv.inv_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))
                          u)
                       (@set.range.{u_2 u_3+1} E H
                          (@local_equiv.to_fun.{u_3 u_2} H E
                             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                                I))))
                    u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301      rcases mem_range.1 hy2 with ⟨x, hx⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {ι : Type u_3} {f : ι → α} {x : α}, iff (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x (@set.range.{u_2 u_3+1} α ι f)) (@Exists.{u_3+1} ι (λ (y : ι), @eq.{u_2+1} α (f y) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302      rw ← hx at ⊢ hy1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u)
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303      simp at ⊢ hy1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u)
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304      rcases H x hy1 with ⟨v, v_open, xv, hv⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @Exists.{(max (u_3+1) 1)} (set.{u_3} H) (λ (v : set.{u_3} H), and (@is_open.{u_3} H _inst_4 v) (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v) (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v)) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305      have : ((I.inv_fun ⁻¹&#x27; (u ∩ v)) ∩ (range (I.to_fun)))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306          = ((I.inv_fun ⁻¹&#x27; u) ∩ (range (I.to_fun)) ∩ I.inv_fun ⁻¹&#x27; v),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307      { rw [preimage_inter, inter_assoc, inter_assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 370, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 370, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {f : α → β} {s t : set.{u_3} β}, @eq.{(max (u_2+1) 1)} (set.{u_2} α) (@set.preimage.{u_2 u_3} α β f (@has_inter.inter.{u_3} (set.{u_3} β) (@set.has_inter.{u_3} β) s t)) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@set.preimage.{u_2 u_3} α β f s) (@set.preimage.{u_2 u_3} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b c : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) c) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b c : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) c) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308        congr&#x27; 1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309        rw inter_comm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310      rw this at hv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (set.{u_2} E) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v)) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) u) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)),
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311      exact ⟨I.inv_fun ⁻¹&#x27; v, I.continuous_inv_fun _ v_open, by simpa, hv⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_3} H _inst_4 v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) u) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)),
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)),
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)),
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
H :
  ∀ (x : H),
    @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u →
    @Exists.{(max (u_3+1) 1)} (set.{u_3} H)
      (λ (v : set.{u_3} H),
         and (@is_open.{u_3} H _inst_4 v)
           (and (@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v)
              (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
                 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))
                 (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                    (@set.preimage.{u_2 u_3} E H
                       (@local_equiv.inv_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                       (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
                    (@set.range.{u_2 u_3+1} E H
                       (@local_equiv.to_fun.{u_3 u_2} H E
                          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                             I))))))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u,
v : set.{u_3} H,
v_open : @is_open.{u_3} H _inst_4 v,
xv : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x v,
this :
  @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@has_inter.inter.{u_3} (set.{u_3} H) (@set.has_inter.{u_3} H) u v))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v)),
hv :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             u)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          v))
⊢ @Exists.{(max (u_2+1) 1)} (set.{u_2} E)
    (λ (u_1 : set.{u_2} E),
       and
         (@is_open.{u_2} E
            (@uniform_space.to_topological_space.{u_2} E
               (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
            u_1)
         (and
            (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
                  x)
               u_1)
            (@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                     (@set.preimage.{u_2 u_3} E H
                        (@local_equiv.inv_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))
                        u)
                     (@set.range.{u_2 u_3+1} E H
                        (@local_equiv.to_fun.{u_3 u_2} H E
                           (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                              I))))
                  u_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313    congr    := λf g u hu fg hf, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='H → H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u_3} H _inst_4 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) u) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314      apply hf.congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315      show unique_diff_on 𝕜 ((I.inv_fun ⁻¹&#x27; u) ∩ (range (I.to_fun))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='unique_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' A property ensuring that the tangent cone to `s` at any of its points spans a dense subset of
the whole space.  The main role of this property is to ensure that the differential along `s` is
unique, hence this name. The uniqueness it asserts is proved in `unique_diff_on.eq` in
`fderiv.lean`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316        by { rw inter_comm, exact I.unique_diff.inter (I.continuous_inv_fun _ hu) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='model_with_corners.unique_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (c : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_3} H _inst_4 u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317      rintros y ⟨hy1, hy2⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            u)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318      rcases mem_range.1 hy2 with ⟨x, hx⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1192, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {ι : Type u_3} {f : ι → α} {x : α}, iff (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x (@set.range.{u_2 u_3+1} α ι f)) (@Exists.{u_3+1} ι (λ (y : ι), @eq.{u_2+1} α (f y) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319      rw ← hx at ⊢ hy1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u),
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u)
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320      simp at ⊢ hy1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       u)
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H g
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u
⊢ @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (g x))
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321      rw fg _ hy1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hy1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u
⊢ @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (g x))
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
f g : H → H,
u : set.{u_3} H,
hu : @is_open.{u_3} H _inst_4 u,
fg : ∀ (x : H), @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u → @eq.{u_3+1} H (g x) (f x),
hf :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          u)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))),
y : E,
hy2 :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))),
x : H,
hx :
  @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       x)
    y,
hy1 : @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H) x u
⊢ @eq.{u_2+1} E
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (g x))
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  variable {n}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  /-- Inclusion of the groupoid of `C^n` local diffeos in the groupoid of `C^m` local diffeos when</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  `m ≤ n` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  lemma times_cont_diff_groupoid_le (h : m ≤ n) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328    times_cont_diff_groupoid n I ≤ times_cont_diff_groupoid m I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} [c : has_le.{u_3} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.partial_order.{u_3} H _inst_4)))
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330    rw [times_cont_diff_groupoid, times_cont_diff_groupoid],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{?l_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{?l_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.partial_order.{u_3} H _inst_4)))
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.partial_order.{u_3} H _inst_4)))
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.partial_order.{u_3} H _inst_4)))
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331    apply groupoid_of_pregroupoid_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='groupoid_of_pregroupoid_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 262, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {H : Type u_3} [_inst_1 : topological_space.{u_3} H] (PG₁ PG₂ : @pregroupoid.{u_3} H _inst_1), (∀ (f : H → H) (s : set.{u_3} H), @pregroupoid.property.{u_3} H _inst_1 PG₁ f s → @pregroupoid.property.{u_3} H _inst_1 PG₂ f s) → @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_1) (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_1) (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_1) (@structure_groupoid.partial_order.{u_3} H _inst_1))) (@pregroupoid.groupoid.{u_3} H _inst_1 PG₁) (@pregroupoid.groupoid.{u_3} H _inst_1 PG₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.partial_order.{u_3} H _inst_4)))
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ ∀ (f : H → H) (s : set.{u_3} H),
    @pregroupoid.property.{u_3} H _inst_4
      (@pregroupoid.mk.{u_3} H _inst_4
         (λ (f : H → H) (s : set.{u_3} H),
            @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
              (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                 (@local_equiv.to_fun.{u_3 u_2} H E
                    (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                 (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
              (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                 (@set.preimage.{u_2 u_3} E H
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    s)
                 (@set.range.{u_2 u_3+1} E H
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
         (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
      f
      s →
    @pregroupoid.property.{u_3} H _inst_4
      (@pregroupoid.mk.{u_3} H _inst_4
         (λ (f : H → H) (s : set.{u_3} H),
            @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
              (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                 (@local_equiv.to_fun.{u_3 u_2} H E
                    (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                 (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
              (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                 (@set.preimage.{u_2 u_3} E H
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    s)
                 (@set.range.{u_2 u_3+1} E H
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
         (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
      f
      s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332    assume f s hfs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n
⊢ ∀ (f : H → H) (s : set.{u_3} H),
    @pregroupoid.property.{u_3} H _inst_4
      (@pregroupoid.mk.{u_3} H _inst_4
         (λ (f : H → H) (s : set.{u_3} H),
            @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
              (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                 (@local_equiv.to_fun.{u_3 u_2} H E
                    (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                 (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
              (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                 (@set.preimage.{u_2 u_3} E H
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    s)
                 (@set.range.{u_2 u_3+1} E H
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
         (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
      f
      s →
    @pregroupoid.property.{u_3} H _inst_4
      (@pregroupoid.mk.{u_3} H _inst_4
         (λ (f : H → H) (s : set.{u_3} H),
            @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
              (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                 (@local_equiv.to_fun.{u_3 u_2} H E
                    (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                 (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
              (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                 (@set.preimage.{u_2 u_3} E H
                    (@local_equiv.inv_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                    s)
                 (@set.range.{u_2 u_3+1} E H
                    (@local_equiv.to_fun.{u_3 u_2} H E
                       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
         (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
         (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
      f
      s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n,
f : H → H,
s : set.{u_3} H,
hfs :
  @pregroupoid.property.{u_3} H _inst_4
    (@pregroupoid.mk.{u_3} H _inst_4
       (λ (f : H → H) (s : set.{u_3} H),
          @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
            (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
               (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
            (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
               (@set.preimage.{u_2 u_3} E H
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  s)
               (@set.range.{u_2 u_3+1} E H
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
       (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    f
    s
⊢ @pregroupoid.property.{u_3} H _inst_4
    (@pregroupoid.mk.{u_3} H _inst_4
       (λ (f : H → H) (s : set.{u_3} H),
          @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
            (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
               (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
            (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
               (@set.preimage.{u_2 u_3} E H
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  s)
               (@set.range.{u_2 u_3+1} E H
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
       (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    f
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333    exact times_cont_diff_on.of_le hfs h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='times_cont_diff_on.of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 419, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_2} [_inst_4 : normed_group.{u_2} F] [_inst_5 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4] {s : set.{u_2} E} {f : E → F} {m n : with_top.{0} nat}, @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E F _inst_2 _inst_3 _inst_4 _inst_5 f s → @has_le.le.{0} (with_top.{0} nat) (@preorder.to_has_le.{0} (with_top.{0} nat) (@with_top.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))) m n → @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E F _inst_2 _inst_3 _inst_4 _inst_5 f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@pregroupoid.property.{u_3} H _inst_4 (@pregroupoid.mk.{u_3} H _inst_4 (λ (f : H → H) (s : set.{u_3} H), @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) s) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))) (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} (with_top.{0} nat) (@preorder.to_has_le.{0} (with_top.{0} nat) (@with_top.preorder.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))) m n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
h :
  @has_le.le.{0} (with_top.{0} nat)
    (@preorder.to_has_le.{0} (with_top.{0} nat)
       (@with_top.preorder.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@ordered_comm_monoid.to_partial_order.{0} nat
                (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                   (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))))
    m
    n,
f : H → H,
s : set.{u_3} H,
hfs :
  @pregroupoid.property.{u_3} H _inst_4
    (@pregroupoid.mk.{u_3} H _inst_4
       (λ (f : H → H) (s : set.{u_3} H),
          @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
            (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
               (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
            (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
               (@set.preimage.{u_2 u_3} E H
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  s)
               (@set.range.{u_2 u_3+1} E H
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
       (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    f
    s
⊢ @pregroupoid.property.{u_3} H _inst_4
    (@pregroupoid.mk.{u_3} H _inst_4
       (λ (f : H → H) (s : set.{u_3} H),
          @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 m E E _inst_2 _inst_3 _inst_2 _inst_3
            (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
               (@local_equiv.to_fun.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
               (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
            (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
               (@set.preimage.{u_2 u_3} E H
                  (@local_equiv.inv_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  s)
               (@set.range.{u_2 u_3+1} E H
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
       (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} m 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
    f
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  /-- The groupoid of `0`-times continuously differentiable maps is just the groupoid of all</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  local homeomorphisms -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  lemma times_cont_diff_groupoid_zero_eq :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    times_cont_diff_groupoid 0 I = continuous_groupoid H :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_1) [_inst_2 : topological_space.{u_1} H], @structure_groupoid.{u_1} H _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The groupoid of all local homeomorphisms on a topological space H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{u_3+1} (@structure_groupoid.{u_3} H _inst_4)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)
    (@continuous_groupoid.{u_3} H _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341    apply le_antisymm lattice.le_top,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.le_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : partial_order.{u_3} α] {a b : α}, @has_le.le.{u_3} α (@preorder.to_has_le.{u_3} α (@partial_order.to_preorder.{u_3} α _inst_1)) a b → @has_le.le.{u_3} α (@preorder.to_has_le.{u_3} α (@partial_order.to_preorder.{u_3} α _inst_1)) b a → @eq.{u_3+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : lattice.order_top.{u_3} α] {a : α}, @has_le.le.{u_3} α (@preorder.to_has_le.{u_3} α (@partial_order.to_preorder.{u_3} α (@lattice.order_top.to_partial_order.{u_3} α _inst_1))) a (@lattice.has_top.top.{u_3} α (@lattice.order_top.to_has_top.{u_3} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @eq.{u_3+1} (@structure_groupoid.{u_3} H _inst_4)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)
    (@continuous_groupoid.{u_3} H _inst_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_partial_order.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
    (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.lattice.order_top.{u_3} H _inst_4)))
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342    assume u hu,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
⊢ @has_le.le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
    (@preorder.to_has_le.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@partial_order.to_preorder.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_partial_order.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
    (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
       (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@structure_groupoid.lattice.order_top.{u_3} H _inst_4)))
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@times_cont_diff_groupoid.{u_1 u_2 u_3}
          (@has_zero.zero.{0} (with_top.{0} nat)
             (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                   (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)
                      nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)))))
          𝕜
          _inst_1
          E
          _inst_2
          _inst_3
          H
          _inst_4
          I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343    -- we have to check that every local homeomorphism belongs to `times_cont_diff_groupoid 0 I`,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@times_cont_diff_groupoid.{u_1 u_2 u_3}
          (@has_zero.zero.{0} (with_top.{0} nat)
             (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                   (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)
                      nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)))))
          𝕜
          _inst_1
          E
          _inst_2
          _inst_3
          H
          _inst_4
          I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344    -- by unfolding its definition</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@times_cont_diff_groupoid.{u_1 u_2 u_3}
          (@has_zero.zero.{0} (with_top.{0} nat)
             (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                   (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)
                      nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)))))
          𝕜
          _inst_1
          E
          _inst_2
          _inst_3
          H
          _inst_4
          I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345    change u ∈ times_cont_diff_groupoid 0 I,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@times_cont_diff_groupoid.{u_1 u_2 u_3}
          (@has_zero.zero.{0} (with_top.{0} nat)
             (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                   (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)
                      nat.canonically_ordered_comm_semiring
                      (λ (a b : nat), nat.decidable_eq a b)))))
          𝕜
          _inst_1
          E
          _inst_2
          _inst_3
          H
          _inst_4
          I))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    u
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_groupoid_of_pregroupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{?l_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {H : Type u_3} [_inst_1 : topological_space.{u_3} H] (PG : @pregroupoid.{u_3} H _inst_1) (e : @local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1), iff (@has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (@structure_groupoid.{u_3} H _inst_1) (@structure_groupoid.has_mem.{u_3} H _inst_1) e (@pregroupoid.groupoid.{u_3} H _inst_1 PG)) (and (@pregroupoid.property.{u_3} H _inst_1 PG (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e)) (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e))) (@pregroupoid.property.{u_3} H _inst_1 PG (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e)) (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    u
    (@times_cont_diff_groupoid.{u_1 u_2 u_3}
       (@has_zero.zero.{0} (with_top.{0} nat)
          (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
             (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)
                   nat.canonically_ordered_comm_semiring
                   (λ (a b : nat), nat.decidable_eq a b)))))
       𝕜
       _inst_1
       E
       _inst_2
       _inst_3
       H
       _inst_4
       I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    u
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1
               (@has_zero.zero.{0} (with_top.{0} nat)
                  (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                     (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                        (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)
                           nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)))))
               E
               E
               _inst_2
               _inst_3
               _inst_2
               _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ and
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1
               (@has_zero.zero.{0} (with_top.{0} nat)
                  (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                     (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                        (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)
                           nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)))))
               E
               E
               _inst_2
               _inst_3
               _inst_2
               _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I))
       (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1
               (@has_zero.zero.{0} (with_top.{0} nat)
                  (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                     (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                        (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)
                           nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)))))
               E
               E
               _inst_2
               _inst_3
               _inst_2
               _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I))
       (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347    simp only [times_cont_diff_on_zero],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='times_cont_diff_on_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 364, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {F : Type ?l_2} [_inst_4 : normed_group.{?l_2} F] [_inst_5 : @normed_space.{?l_1 ?l_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_4] {s : set.{?l_2} E} {f : E → F}, iff (@times_cont_diff_on.{?l_2 ?l_1} 𝕜 _inst_1 (@has_zero.zero.{0} (with_top.{0} nat) (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat) (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat) (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring (λ (a b : nat), nat.decidable_eq a b) nat.canonically_ordered_comm_semiring (λ (a b : nat), nat.decidable_eq a b))))) E F _inst_2 _inst_3 _inst_4 _inst_5 f s) (@continuous_on.{?l_2 ?l_2} E F (@uniform_space.to_topological_space.{?l_2} E (@metric_space.to_uniform_space&#x27;.{?l_2} E (@normed_group.to_metric_space.{?l_2} E _inst_2))) (@uniform_space.to_topological_space.{?l_2} F (@metric_space.to_uniform_space&#x27;.{?l_2} F (@normed_group.to_metric_space.{?l_2} F _inst_4))) f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ and
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1
               (@has_zero.zero.{0} (with_top.{0} nat)
                  (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                     (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                        (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)
                           nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)))))
               E
               E
               _inst_2
               _inst_3
               _inst_2
               _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I))
       (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1
               (@has_zero.zero.{0} (with_top.{0} nat)
                  (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                     (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                        (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)
                           nat.canonically_ordered_comm_semiring
                           (λ (a b : nat), nat.decidable_eq a b)))))
               E
               E
               _inst_2
               _inst_3
               _inst_2
               _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3}
             (@has_zero.zero.{0} (with_top.{0} nat)
                (@zero_ne_one_class.to_has_zero.{0} (with_top.{0} nat)
                   (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} (with_top.{0} nat)
                      (@with_top.canonically_ordered_comm_semiring.{0} nat nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)
                         nat.canonically_ordered_comm_semiring
                         (λ (a b : nat), nat.decidable_eq a b)))))
             𝕜
             _inst_1
             E
             _inst_2
             _inst_3
             H
             _inst_4
             I))
       (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ and
    (@continuous_on.{u_2 u_2} E E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
             (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@continuous_on.{u_2 u_2} E E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
             (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ and
    (@continuous_on.{u_2 u_2} E E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
             (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@continuous_on.{u_2 u_2} E E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
             (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_3} E H
             (@local_equiv.inv_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
             (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349    { apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous_to_fun)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous.continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {γ : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_2} γ] {g : β → γ} {f : α → β} {s : set.{u_2} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_2} β γ _inst_2 _inst_3 g t → @continuous_on.{u_2 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t) → @continuous_on.{u_2 u_2} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_3} {β : Type u_2} [_inst_1 : topological_space.{u_3} α] [_inst_2 : topological_space.{u_2} β] {f : α → β} {s : set.{u_3} α}, @continuous.{u_3 u_2} α β _inst_1 _inst_2 f → @continuous_on.{u_3 u_2} α β _inst_1 _inst_2 f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350        _ (subset_univ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.subset_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 240, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351      apply continuous_on.comp u.continuous_to_fun I.continuous_inv_fun.continuous_on</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β γ : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β} {s : set.{u_2} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_3} β γ _inst_2 _inst_3 g t → @continuous_on.{u_2 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t) → @continuous_on.{u_2 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_3+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352        (inter_subset_left _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s t : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353    { apply continuous_on.comp (@continuous.continuous_on _ _ _ _ _ univ I.continuous_to_fun)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous.continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {γ : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_2} γ] {g : β → γ} {f : α → β} {s : set.{u_2} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_2} β γ _inst_2 _inst_3 g t → @continuous_on.{u_2 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t) → @continuous_on.{u_2 u_2} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_3} {β : Type u_2} [_inst_1 : topological_space.{u_3} α] [_inst_2 : topological_space.{u_2} β] {f : α → β} {s : set.{u_3} α}, @continuous.{u_3 u_2} α β _inst_1 _inst_2 f → @continuous_on.{u_3 u_2} α β _inst_1 _inst_2 f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354        _ (subset_univ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.subset_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 240, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_2} E E
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
          (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355      apply continuous_on.comp u.continuous_inv_fun I.continuous_inv_fun.continuous_on</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β γ : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_3} γ] {g : β → γ} {f : α → β} {s : set.{u_2} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_3} β γ _inst_2 _inst_3 g t → @continuous_on.{u_2 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t) → @continuous_on.{u_2 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_3+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356        (inter_subset_left _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s t : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
u : @local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4,
hu :
  @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4))
    u
    (@structure_groupoid.members.{u_3} H _inst_4
       (@lattice.has_top.top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
          (@lattice.order_top.to_has_top.{u_3} (@structure_groupoid.{u_3} H _inst_4)
             (@structure_groupoid.lattice.order_top.{u_3} H _inst_4))))
⊢ @continuous_on.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (@function.comp.{u_2+1 u_3+1 u_3+1} E H H
       (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4 u)))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  variable (n)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  /-- An identity local homeomorphism belongs to the `C^n` groupoid. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  lemma of_set_mem_times_cont_diff_groupoid {s : set H} (hs : is_open s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362    local_homeomorph.of_set s hs ∈ times_cont_diff_groupoid n I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_homeomorph.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α] (s : set.{u_1} α), @is_open.{u_1} α _inst_1 s → @local_homeomorph.{u_1 u_1} α α _inst_1 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u_3} H _inst_4 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The identity local equiv on a set `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364    rw [times_cont_diff_groupoid, mem_groupoid_of_pregroupoid],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_groupoid_of_pregroupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{?l_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {H : Type u_3} [_inst_1 : topological_space.{u_3} H] (PG : @pregroupoid.{u_3} H _inst_1) (e : @local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1), iff (@has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (@structure_groupoid.{u_3} H _inst_1) (@structure_groupoid.has_mem.{u_3} H _inst_1) e (@pregroupoid.groupoid.{u_3} H _inst_1 PG)) (and (@pregroupoid.property.{u_3} H _inst_1 PG (@local_equiv.to_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e)) (@local_equiv.source.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e))) (@pregroupoid.property.{u_3} H _inst_1 PG (@local_equiv.inv_fun.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e)) (@local_equiv.target.{u_3 u_3} H H (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_1 _inst_1 e))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)
    (@pregroupoid.groupoid.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ and
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.to_fun.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)))
       (@local_equiv.source.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs))))
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)))
       (@local_equiv.target.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    suffices h : times_cont_diff_on 𝕜 n (I.to_fun ∘ I.inv_fun) (I.inv_fun ⁻¹&#x27; s ∩ range I.to_fun),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='times_cont_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_8 : nondiscrete_normed_field.{u_1} 𝕜], with_top.{0} nat → Π {E F : Type u_2} [_inst_9 : normed_group.{u_2} E] [_inst_10 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_8) _inst_9] [_inst_11 : normed_group.{u_2} F] [_inst_12 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_8) _inst_11], (E → F) → set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3} {φ : Type u_2}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {ι : Type u_3}, (ι → α) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function is `C^n` on a set, for `n : with_top ℕ`, if its derivatives of order at most `n`
are all well defined and continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ and
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.to_fun.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)))
       (@local_equiv.source.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs))))
    (@pregroupoid.property.{u_3} H _inst_4
       (@pregroupoid.mk.{u_3} H _inst_4
          (λ (f : H → H) (s : set.{u_3} H),
             @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
               (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
                  (@local_equiv.to_fun.{u_3 u_2} H E
                     (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                  (@function.comp.{u_2+1 u_3+1 u_3+1} E H H f
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
               (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
                  (@set.preimage.{u_2 u_3} E H
                     (@local_equiv.inv_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
                     s)
                  (@set.range.{u_2 u_3+1} E H
                     (@local_equiv.to_fun.{u_3 u_2} H E
                        (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4
                           I)))))
          (@times_cont_diff_groupoid._proof_1.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_2.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_3.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@times_cont_diff_groupoid._proof_4.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs)))
       (@local_equiv.target.{u_3 u_3} H H
          (@local_homeomorph.to_local_equiv.{u_3 u_3} H H _inst_4 _inst_4
             (@local_homeomorph.of_set.{u_3} H _inst_4 s hs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366      by simp [h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@function.comp.{u_2+1 u_3+1 u_2+1} E H E (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) s) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367    have : times_cont_diff_on 𝕜 n id (univ : set E) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='times_cont_diff_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_8 : nondiscrete_normed_field.{u_1} 𝕜], with_top.{0} nat → Π {E F : Type u_2} [_inst_9 : normed_group.{u_2} E] [_inst_10 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_8) _inst_9] [_inst_11 : normed_group.{u_2} F] [_inst_12 : @normed_space.{u_1 u_2} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_8) _inst_11], (E → F) → set.{u_2} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function is `C^n` on a set, for `n : with_top ℕ`, if its derivatives of order at most `n`
are all well defined and continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368      times_cont_diff_id.times_cont_diff_on is_open_univ.unique_diff_on,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='times_cont_diff_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 669, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {n : with_top.{0} nat}, @times_cont_diff.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [t : topological_space.{u_2} α], @is_open.{u_2} α t (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The identity is C^∞.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369    apply this.congr_mono _ _ (subset_univ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.subset_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/times_cont_diff.lean&#x27;, &#x27;line&#x27;: 502, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 240, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.univ.{u_2} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            s)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@local_equiv.inv_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370    { rw inter_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            s)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@local_equiv.inv_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371      exact I.unique_diff.inter (I.continuous_inv_fun s hs) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='model_with_corners.unique_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (c : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_3} H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_open.{u_3} H _inst_4 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ @unique_diff_on.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            s)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@local_equiv.inv_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372    { assume x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E)
⊢ ∀ (x : E),
    @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
      (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
         (@set.preimage.{u_2 u_3} E H
            (@local_equiv.inv_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
            s)
         (@set.range.{u_2 u_3+1} E H
            (@local_equiv.to_fun.{u_3 u_2} H E
               (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))) →
    @eq.{u_2+1} E
      (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
         (@local_equiv.to_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         (@local_equiv.inv_fun.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
         x)
      (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E),
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373      simp [hx.2] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_3} E H (@local_equiv.inv_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) s) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
s : set.{u_3} H,
hs : @is_open.{u_3} H _inst_4 s,
this :
  @times_cont_diff_on.{u_2 u_1} 𝕜 _inst_1 n E E _inst_2 _inst_3 _inst_2 _inst_3 (@id.{u_2+1} E) (@set.univ.{u_2} E),
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          s)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
⊢ @eq.{u_2+1} E
    (@function.comp.{u_2+1 u_3+1 u_2+1} E H E
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       x)
    (@id.{u_2+1} E x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376  /-- The composition of a local homeomorphism from `H` to `M` and its inverse belongs to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377  the `C^n` groupoid. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378  lemma symm_trans_mem_times_cont_diff_groupoid (e : local_homeomorph M H) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='local_homeomorph'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Π (α : Type u_5) (β : Type u_6) [_inst_5 : topological_space.{u_5} α] [_inst_6 : topological_space.{u_6} β], Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='local homeomorphisms, defined on open subsets of the space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379    e.symm.trans e ∈ times_cont_diff_groupoid n I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_homeomorph.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_homeomorph.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_3} β], @local_homeomorph.{u_4 u_3} α β _inst_1 _inst_2 → @local_homeomorph.{u_3 u_4} β α _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_4} {γ : Type u_3} [_inst_1 : topological_space.{u_3} α] [_inst_2 : topological_space.{u_4} β] [_inst_3 : topological_space.{u_3} γ], @local_homeomorph.{u_3 u_4} α β _inst_1 _inst_2 → @local_homeomorph.{u_4 u_3} β γ _inst_2 _inst_3 → @local_homeomorph.{u_3 u_3} α γ _inst_1 _inst_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The inverse of a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Composing two local homeomorphisms, by restricting to the maximal domain where their
composition is well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381    have : e.symm.trans e ≈ local_homeomorph.of_set e.target e.open_target :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='local_homeomorph.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_equiv.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_3} β], @local_homeomorph.{u_4 u_3} α β _inst_1 _inst_2 → @local_homeomorph.{u_3 u_4} β α _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} [c : has_equiv.{u_3+1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : topological_space.{u_3} α] (s : set.{u_3} α), @is_open.{u_3} α _inst_1 s → @local_homeomorph.{u_3 u_3} α α _inst_1 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3}, local_equiv.{u_4 u_3} α β → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse of a local homeomorphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The identity local equiv on a set `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382      local_homeomorph.trans_symm_self _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_homeomorph.trans_symm_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_3} β] (e : @local_homeomorph.{u_4 u_3} α β _inst_1 _inst_2), @has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} β β _inst_2 _inst_2) (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} β β _inst_2 _inst_2) (@local_homeomorph.setoid.{u_3 u_3} β β _inst_2 _inst_2)) (@local_homeomorph.trans.{u_3 u_4 u_3} β α β _inst_2 _inst_1 _inst_2 (@local_homeomorph.symm.{u_4 u_3} α β _inst_1 _inst_2 e) e) (@local_homeomorph.of_set.{u_3} β _inst_2 (@local_equiv.target.{u_4 u_3} α β (@local_homeomorph.to_local_equiv.{u_4 u_3} α β _inst_1 _inst_2 e)) (@local_homeomorph.open_target.{u_4 u_3} α β _inst_1 _inst_2 e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4,
this :
  @has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
       (@local_homeomorph.setoid.{u_3 u_3} H H _inst_4 _inst_4))
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@local_homeomorph.of_set.{u_3} H _inst_4
       (@local_equiv.target.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 e))
       (@local_homeomorph.open_target.{u_4 u_3} M H _inst_5 _inst_4 e))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>383    exact structure_groupoid.eq_on_source _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='structure_groupoid.eq_on_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {H : Type u_3} [_inst_1 : topological_space.{u_3} H] (c : @structure_groupoid.{u_3} H _inst_1) (e e&#x27; : @local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1), @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1)) (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1)) e (@structure_groupoid.members.{u_3} H _inst_1 c) → @has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (@local_homeomorph.setoid.{u_3 u_3} H H _inst_1 _inst_1)) e&#x27; e → @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1) (set.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1)) (@set.has_mem.{u_3} (@local_homeomorph.{u_3 u_3} H H _inst_1 _inst_1)) e&#x27; (@structure_groupoid.members.{u_3} H _inst_1 c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4,
this :
  @has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
       (@local_homeomorph.setoid.{u_3 u_3} H H _inst_4 _inst_4))
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@local_homeomorph.of_set.{u_3} H _inst_4
       (@local_equiv.target.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 e))
       (@local_homeomorph.open_target.{u_4 u_3} M H _inst_5 _inst_4 e))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>384      (of_set_mem_times_cont_diff_groupoid n I e.open_target) this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='of_set_mem_times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 361, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (n : with_top.{0} nat) {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {s : set.{u_3} H} (hs : @is_open.{u_3} H _inst_4 s), @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4) (@structure_groupoid.has_mem.{u_3} H _inst_4) (@local_homeomorph.of_set.{u_3} H _inst_4 s hs) (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='with_top.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@local_homeomorph.setoid.{u_3 u_3} H H _inst_4 _inst_4)) (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4 (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e) e) (@local_homeomorph.of_set.{u_3} H _inst_4 (@local_equiv.target.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 e)) (@local_homeomorph.open_target.{u_4 u_3} M H _inst_5 _inst_4 e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An identity local homeomorphism belongs to the `C^n` groupoid.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : with_top.{0} nat,
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
e : @local_homeomorph.{u_4 u_3} M H _inst_5 _inst_4,
this :
  @has_equiv.equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
    (@setoid_has_equiv.{u_3+1} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4)
       (@local_homeomorph.setoid.{u_3 u_3} H H _inst_4 _inst_4))
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@local_homeomorph.of_set.{u_3} H _inst_4
       (@local_equiv.target.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 e))
       (@local_homeomorph.open_target.{u_4 u_3} M H _inst_5 _inst_4 e))
⊢ @has_mem.mem.{u_3 u_3} (@local_homeomorph.{u_3 u_3} H H _inst_4 _inst_4) (@structure_groupoid.{u_3} H _inst_4)
    (@structure_groupoid.has_mem.{u_3} H _inst_4)
    (@local_homeomorph.trans.{u_3 u_4 u_3} H M H _inst_4 _inst_5 _inst_4
       (@local_homeomorph.symm.{u_4 u_3} M H _inst_5 _inst_4 e)
       e)
    (@times_cont_diff_groupoid.{u_1 u_2 u_3} n 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>385  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>386  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>387  end times_cont_diff_groupoid</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>388  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>389  end model_with_corners</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>390  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>391  /-! ### Smooth manifolds with corners -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>392  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>393  /-- Typeclass defining smooth manifolds with corners with respect to a model with corners, over a</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>394  field `𝕜` and with infinite smoothness to simplify typeclass search and statements later on. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>395  class smooth_manifold_with_corners {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>396    {E : Type*} [normed_group E] [normed_space 𝕜 E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>397    {H : Type*} [topological_space H] (I : model_with_corners 𝕜 E H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>398    (M : Type*) [topological_space M] [manifold H M] extends</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='manifold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] (M : Type u_4) [_inst_2 : topological_space.{u_4} M], Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A manifold is a topological space endowed with an atlas, i.e., a set of local homeomorphisms
taking value in a model space H, called charts, such that the domains of the charts cover the whole
space. We express the covering property by chosing for each x a member `chart_at x` of the atlas
containing x in its source: in the smooth case, this is convenient to construct the tangent bundle
in an efficient way.
The model space is written as an explicit parameter as there can be several model spaces for a
given topological space. For instance, a complex manifold (modelled over ℂ^n) will also be seen
sometimes as a real manifold over ℝ^(2n).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>399    has_groupoid M (times_cont_diff_groupoid ⊤ I) : Prop</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='times_cont_diff_groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 420, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 270, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (M : Type u_4) [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], @structure_groupoid.{u_3} H _inst_4 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='with_top.{0} nat → Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → @structure_groupoid.{u_3} H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type) [c : lattice.has_top.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A manifold has an atlas in a groupoid G if the change of coordinates belong to the groupoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Given a model with corners `(E, H)`, we define the groupoid of `C^n` transformations of `H` as
the maps that are `C^n` when read in `E` through `I`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>400  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>401  /-- For any model with corners, the model space is a smooth manifold -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>402  instance model_space_smooth {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>403    {E : Type*} [normed_group E] [normed_space 𝕜 E] {H : Type*} [topological_space H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>404    {I : model_with_corners 𝕜 E H} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>405    smooth_manifold_with_corners I H := {}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smooth_manifold_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π (M : Type u_4) [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Typeclass defining smooth manifolds with corners with respect to a model with corners, over a
field `𝕜` and with infinite smoothness to simplify typeclass search and statements later on.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>406  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>407  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>408  section extended_charts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>409  open_locale topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>410  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>411  variables {𝕜 : Type*} [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>412    {E : Type*} [normed_group E] [normed_space 𝕜 E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>413    {H : Type*} [topological_space H] (I : model_with_corners 𝕜 E H)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='model_with_corners'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] (H : Type u_3) [_inst_4 : topological_space.{u_3} H], Type (max u_2 u_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title=' A structure containing informations on the way a space `H` embeds in a
model vector space `E` over the field `𝕜`. This is all what is needed to
define a smooth manifold with model space `H`, and model vector space `E`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>414    {M : Type*} [topological_space M] [manifold H M]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='manifold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] (M : Type u_4) [_inst_2 : topological_space.{u_4} M], Type (max u_3 u_4)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A manifold is a topological space endowed with an atlas, i.e., a set of local homeomorphisms
taking value in a model space H, called charts, such that the domains of the charts cover the whole
space. We express the covering property by chosing for each x a member `chart_at x` of the atlas
containing x in its source: in the smooth case, this is convenient to construct the tangent bundle
in an efficient way.
The model space is written as an explicit parameter as there can be several model spaces for a
given topological space. For instance, a complex manifold (modelled over ℂ^n) will also be seen
sometimes as a real manifold over ℝ^(2n).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>415    (x : M) {s t : set M}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>416  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>417  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>418  ### Extended charts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>419  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>420  In a smooth manifold with corners, the model space is the space `H`. However, we will also</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>421  need to use extended charts taking values in the model vector space `E`. These extended charts are</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>422  not `local_homeomorph` as the target is not open in `E` in general, but we can still register them</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>423  as `local_equiv`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>424  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>425  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>426  /-- The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>427  of `x` to the model vector space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>428  def ext_chart_at (x : M) : local_equiv M E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_5 → Type u_6 → Type (max u_5 u_6)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Local equivalence between subsets `source` and `target` of α and β respectively. The (global)
maps `to_fun : α → β` and `inv_fun : β → α` map `source` to `target` and conversely, and are inverse
to each other there. The values of `to_fun` outside of `source` and of `inv_fun` outside of `target`
are irrelevant.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>429  (chart_at H x).to_local_equiv.trans I.to_local_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_homeomorph.to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='model_with_corners.to_local_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_homeomorph.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_4) [_inst_1 : topological_space.{u_4} H] {M : Type u_5} [_inst_2 : topological_space.{u_5} M] [c : @manifold.{u_4 u_5} H _inst_1 M _inst_2], M → @local_homeomorph.{u_5 u_4} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3} [_inst_5 : topological_space.{u_4} α] [_inst_6 : topological_space.{u_3} β], @local_homeomorph.{u_4 u_3} α β _inst_5 _inst_6 → local_equiv.{u_4 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3} {γ : Type u_2}, local_equiv.{u_4 u_3} α β → local_equiv.{u_3 u_2} β γ → local_equiv.{u_4 u_2} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → local_equiv.{u_3 u_2} H E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title=' Composing two local equivs, by restricting to the maximal domain where their composition
is well defined.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>430  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>431  lemma ext_chart_at_source : (ext_chart_at I x).source = (chart_at H x).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_4}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (H : Type u_4) [_inst_1 : topological_space.{u_4} H] {M : Type u_5} [_inst_2 : topological_space.{u_5} M] [c : @manifold.{u_4 u_5} H _inst_1 M _inst_2], M → @local_homeomorph.{u_5 u_4} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_3}, local_equiv.{u_4 u_3} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>432  by rw [ext_chart_at, local_equiv.trans_source, I.source_eq, preimage_univ, inter_univ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.preimage_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 843, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 396, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} {γ : Type u_2} (e : local_equiv.{u_4 u_3} α β) (e&#x27; : local_equiv.{u_3 u_2} β γ), @eq.{(max (u_4+1) 1)} (set.{u_4} α) (@local_equiv.source.{u_4 u_2} α γ (@local_equiv.trans.{u_4 u_3 u_2} α β γ e e&#x27;)) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) (@local_equiv.source.{u_4 u_3} α β e) (@set.preimage.{u_4 u_3} α β (@local_equiv.to_fun.{u_4 u_3} α β e) (@local_equiv.source.{u_3 u_2} β γ e&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_3+1) 1)} (@(λ {α : Type u_3} {β : Type u_2} (c : local_equiv.{u_3 u_2} α β), set.{u_3} α) H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@local_equiv.source.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.univ.{u_3} H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} {f : α → β}, @eq.{(max (u_4+1) 1)} (set.{u_4} α) (@set.preimage.{u_4 u_3} α β f (@set.univ.{u_3} β)) (@set.univ.{u_4} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} (a : set.{u_4} α), @eq.{u_4+1} (set.{u_4} α) (@has_inter.inter.{u_4} (set.{u_4} α) (@set.has_inter.{u_4} α) a (@set.univ.{u_4} α)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@local_equiv.source.{u_4 u_2} M E
       (@local_equiv.trans.{u_4 u_3 u_2} M H E
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@has_inter.inter.{u_4} (set.{u_4} M) (@set.has_inter.{u_4} M)
       (@local_equiv.source.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
       (@set.preimage.{u_4 u_3} M H
          (@local_equiv.to_fun.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
          (@local_equiv.source.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@has_inter.inter.{u_4} (set.{u_4} M) (@set.has_inter.{u_4} M)
       (@local_equiv.source.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
       (@set.preimage.{u_4 u_3} M H
          (@local_equiv.to_fun.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
          (@set.univ.{u_3} H)))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@has_inter.inter.{u_4} (set.{u_4} M) (@set.has_inter.{u_4} M)
       (@local_equiv.source.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
       (@set.univ.{u_4} M))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>433  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{(max (u_4+1) 1)} (set.{u_4} M)
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>434  lemma ext_chart_at_open_source : is_open (ext_chart_at I x).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Type u} [t : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>435  by { rw ext_chart_at_source, exact (chart_at H x).open_source }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ext_chart_at_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 431, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @eq.{(max (u_4+1) 1)} (set.{u_4} M) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @is_open.{u_4} M _inst_5
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @is_open.{u_4} M _inst_5
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>436  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>437  @[simp] lemma mem_ext_chart_source : x ∈ (ext_chart_at I x).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>438  by { rw ext_chart_at_source, exact mem_chart_source _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ext_chart_at_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='manifold.mem_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 431, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @eq.{(max (u_4+1) 1)} (set.{u_4} M) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_2 _inst_1 (@manifold.chart_at.{u_3 u_4} H _inst_1 M _inst_2 c x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>439  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>440  @[simp] lemma ext_chart_at_to_inv :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>441    (ext_chart_at I x).inv_fun ((ext_chart_at I x).to_fun x) = x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_4}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>442  by rw (ext_chart_at I x).left_inv (mem_ext_chart_source _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{u_4+1} M
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>443  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{u_4+1} M
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>444  lemma ext_chart_at_source_mem_nhds : (ext_chart_at I x).source ∈ 𝓝 x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} [_inst_1 : topological_space.{u_4} α], α → filter.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>445  mem_nhds_sets (ext_chart_at_open_source I x) (mem_ext_chart_source I x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at_open_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 434, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} [_inst_1 : topological_space.{u_4} α] {a : α} {s : set.{u_4} α}, @is_open.{u_4} α _inst_1 s → @has_mem.mem.{u_4 u_4} α (set.{u_4} α) (@set.has_mem.{u_4} α) a s → @has_mem.mem.{u_4 u_4} (set.{u_4} α) (filter.{u_4} α) (@filter.has_mem.{u_4} α) s (@nhds.{u_4} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @is_open.{u_4} M _inst_5 (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>446  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>447  lemma ext_chart_at_continuous_on_to_fun :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>448    continuous_on (ext_chart_at I x).to_fun (ext_chart_at I x).source :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function between topological spaces is continuous on a subset `s`
when it&#x27;s continuous at every point of `s` within `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>449  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_2} M E _inst_5
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>450    refine continuous_on.comp I.continuous_to_fun.continuous_on _ subset_preimage_univ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset_preimage_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} {γ : Type u_2} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_2} γ] {g : β → γ} {f : α → β} {s : set.{u_4} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_2} β γ _inst_2 _inst_3 g t → @continuous_on.{u_4 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) s (@set.preimage.{u_4 u_3} α β f t) → @continuous_on.{u_4 u_2} α γ _inst_1 _inst_3 (@function.comp.{u_4+1 u_3+1 u_2+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} {f : α → β} {s : set.{u_4} α}, @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) s (@set.preimage.{u_4 u_3} α β f (@set.univ.{u_3} β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_2} M E _inst_5
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_3} M H _inst_5 _inst_4
    (λ (x_1 : M),
       @local_equiv.to_fun.{u_4 u_3} M H
         (@local_equiv.symm.{u_3 u_4} H M
            (@local_equiv.restr.{u_3 u_4} H M
               (@local_equiv.symm.{u_4 u_3} M H
                  (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                     (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
               (@local_equiv.source.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
         x_1)
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>451    rw ext_chart_at_source,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ext_chart_at_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 431, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @eq.{(max (u_4+1) 1)} (set.{u_4} M) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_3} M H _inst_5 _inst_4
    (λ (x_1 : M),
       @local_equiv.to_fun.{u_4 u_3} M H
         (@local_equiv.symm.{u_3 u_4} H M
            (@local_equiv.restr.{u_3 u_4} H M
               (@local_equiv.symm.{u_4 u_3} M H
                  (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                     (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
               (@local_equiv.source.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
         x_1)
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_3} M H _inst_5 _inst_4
    (λ (x_1 : M),
       @local_equiv.to_fun.{u_4 u_3} M H
         (@local_equiv.symm.{u_3 u_4} H M
            (@local_equiv.restr.{u_3 u_4} H M
               (@local_equiv.symm.{u_4 u_3} M H
                  (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                     (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
               (@local_equiv.source.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
         x_1)
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>452    exact (chart_at H x).continuous_to_fun</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_4 u_3} M H _inst_5 _inst_4
    (λ (x_1 : M),
       @local_equiv.to_fun.{u_4 u_3} M H
         (@local_equiv.symm.{u_3 u_4} H M
            (@local_equiv.restr.{u_3 u_4} H M
               (@local_equiv.symm.{u_4 u_3} M H
                  (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                     (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
               (@local_equiv.source.{u_3 u_2} H E
                  (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
         x_1)
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>453  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>454  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>455  lemma ext_chart_at_continuous_at_to_fun :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>456    continuous_at (ext_chart_at I x).to_fun x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 648, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function between topological spaces is continuous at a point `x₀`
if `f x` tends to `f x₀` when `x` tends to `x₀`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>457  (ext_chart_at_continuous_on_to_fun I x x (mem_ext_chart_source I x)).continuous_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ext_chart_at_continuous_on_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_within_at.continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 447, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 388, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @continuous_on.{u_4 u_2} M E _inst_5 (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_2} [_inst_1 : topological_space.{u_4} α] [_inst_2 : topological_space.{u_2} β] {f : α → β} {s : set.{u_4} α} {x : α}, @continuous_within_at.{u_4 u_2} α β _inst_1 _inst_2 f s x → @has_mem.mem.{u_4 u_4} (set.{u_4} α) (filter.{u_4} α) (@filter.has_mem.{u_4} α) s (@nhds.{u_4} α _inst_1 x) → @continuous_at.{u_4 u_2} α β _inst_1 _inst_2 f x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>458    (ext_chart_at_source_mem_nhds I x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at_source_mem_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 444, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@nhds.{u_4} M _inst_5 x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>459  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>460  lemma ext_chart_at_continuous_on_inv_fun :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>461    continuous_on (ext_chart_at I x).inv_fun (ext_chart_at I x).target :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function between topological spaces is continuous on a subset `s`
when it&#x27;s continuous at every point of `s` within `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>462  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_2 u_4} E M
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_5
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>463    apply continuous_on.comp (chart_at H x).continuous_inv_fun I.continuous_inv_fun.continuous_on,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous_on.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 408, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_4} γ] {g : β → γ} {f : α → β} {s : set.{u_2} α} {t : set.{u_3} β}, @continuous_on.{u_3 u_4} β γ _inst_2 _inst_3 g t → @continuous_on.{u_2 u_3} α β _inst_1 _inst_2 f s → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t) → @continuous_on.{u_2 u_4} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_4+1} α β γ g f) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @continuous_on.{u_2 u_4} E M
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_5
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.target.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>464    simp [ext_chart_at, local_equiv.trans_target]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_3+1) 1)} (set.{?l_3} γ) (@local_equiv.target.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@has_inter.inter.{?l_3} (set.{?l_3} γ) (@set.has_inter.{?l_3} γ) (@local_equiv.target.{?l_2 ?l_3} β γ e&#x27;) (@set.preimage.{?l_3 ?l_2} γ β (@local_equiv.inv_fun.{?l_2 ?l_3} β γ e&#x27;) (@local_equiv.target.{?l_1 ?l_2} α β e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.target.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>465  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>466  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>467  lemma ext_chart_at_target_mem_nhds_within :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>468    (ext_chart_at I x).target ∈ nhds_within ((ext_chart_at I x).to_fun x) (range I.to_fun) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>469  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>470    rw [ext_chart_at, local_equiv.trans_target],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {β : Type u_3} {γ : Type u_2} (e : local_equiv.{u_4 u_3} α β) (e&#x27; : local_equiv.{u_3 u_2} β γ), @eq.{(max (u_2+1) 1)} (set.{u_2} γ) (@local_equiv.target.{u_4 u_2} α γ (@local_equiv.trans.{u_4 u_3 u_2} α β γ e e&#x27;)) (@has_inter.inter.{u_2} (set.{u_2} γ) (@set.has_inter.{u_2} γ) (@local_equiv.target.{u_3 u_2} β γ e&#x27;) (@set.preimage.{u_2 u_3} γ β (@local_equiv.inv_fun.{u_3 u_2} β γ e&#x27;) (@local_equiv.target.{u_4 u_3} α β e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@local_equiv.trans.{u_4 u_3 u_2} M H E
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@local_equiv.trans.{u_4 u_3 u_2} M H E
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@local_equiv.target.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@local_equiv.trans.{u_4 u_3 u_2} M H E
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>471    simp only [function.comp_app, local_equiv.trans_to_fun, model_with_corners_target],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='function.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='model_with_corners_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 287, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 158, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3} (f : β → φ) (g : α → β) (a : α), @eq.{?l_3} φ (@function.comp.{?l_1 ?l_2 ?l_3} α β φ f g a) (f (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_1+1) (?l_3+1))} (α → γ) (@local_equiv.to_fun.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@function.comp.{?l_1+1 ?l_2+1 ?l_3+1} α β γ (@local_equiv.to_fun.{?l_2 ?l_3} β γ e&#x27;) (@local_equiv.to_fun.{?l_1 ?l_2} α β e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H] (I : @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4), @eq.{(max (?l_2+1) 1)} (set.{?l_2} E) (@local_equiv.target.{?l_3 ?l_2} H E (@model_with_corners.to_local_equiv.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)) (@set.range.{?l_2 ?l_3+1} E H (@local_equiv.to_fun.{?l_3 ?l_2} H E (@model_with_corners.to_local_equiv.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@local_equiv.target.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@local_equiv.trans.{u_4 u_3 u_2} M H E
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (set.{u_2} (set.{u_2} E)) (@set.has_mem.{u_2} (set.{u_2} E))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))))
    (@filter.sets.{u_2} E
       (@nhds_within.{u_2} E
          (@uniform_space.to_topological_space.{u_2} E
             (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             (@local_equiv.to_fun.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
                x))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>472    refine inter_mem_nhds_within _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='inter_mem_nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] (s : set.{u_2} α) {t : set.{u_2} α} {a : α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) t (@nhds.{u_2} α _inst_1 a) → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) (@nhds_within.{u_2} α _inst_1 a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (set.{u_2} (set.{u_2} E)) (@set.has_mem.{u_2} (set.{u_2} E))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))))
    (@filter.sets.{u_2} E
       (@nhds_within.{u_2} E
          (@uniform_space.to_topological_space.{u_2} E
             (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             (@local_equiv.to_fun.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
                x))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>473      (mem_nhds_sets (I.continuous_inv_fun _ (chart_at H x).open_target) _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {a : α} {s : set.{u_2} α}, @is_open.{u_2} α _inst_1 s → @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a s → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s (@nhds.{u_2} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (set.{u_2} (set.{u_2} E)) (@set.has_mem.{u_2} (set.{u_2} E))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_3} E H
          (@local_equiv.inv_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))))
    (@filter.sets.{u_2} E
       (@nhds_within.{u_2} E
          (@uniform_space.to_topological_space.{u_2} E
             (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
             (@local_equiv.to_fun.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
                x))
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
          x))
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.target.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>474    simp only [model_with_corners_left_inv, mem_preimage],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='model_with_corners_left_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 161, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H] (I : @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) (x : H), @eq.{?l_3+1} H (@local_equiv.inv_fun.{?l_3 ?l_2} H E (@model_with_corners.to_local_equiv.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) (@local_equiv.to_fun.{?l_3 ?l_2} H E (@model_with_corners.to_local_equiv.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E)
    (@local_equiv.to_fun.{u_3 u_2} H E
       (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
       (@local_equiv.to_fun.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
          x))
    (@set.preimage.{u_2 u_3} E H
       (@local_equiv.inv_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))
       (@local_equiv.target.{u_4 u_3} M H
          (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
             (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x)
    (@local_equiv.target.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>475    exact (chart_at H x).map_source (mem_chart_source _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='manifold.mem_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_2 _inst_1 (@manifold.chart_at.{u_3 u_4} H _inst_1 M _inst_2 c x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_mem.mem.{u_3 u_3} H (set.{u_3} H) (@set.has_mem.{u_3} H)
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x)
    (@local_equiv.target.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>476  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>477  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>478  lemma nhds_within_ext_chart_target_eq :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>479    nhds_within ((ext_chart_at I x).to_fun x) (ext_chart_at I x).target =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>480    nhds_within ((ext_chart_at I x).to_fun x) (range I.to_fun) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>481  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{u_2+1} (filter.{u_2} E)
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>482    apply le_antisymm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : partial_order.{u_2} α] {a b : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α _inst_1)) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α _inst_1)) b a → @eq.{u_2+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @eq.{u_2+1} (filter.{u_2} E)
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>483    { apply nhds_within_mono,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nhds_within_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] (a : α) {s t : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s t → @has_le.le.{u_2} (filter.{u_2} α) (@preorder.to_has_le.{u_2} (filter.{u_2} α) (@partial_order.to_preorder.{u_2} (filter.{u_2} α) (@filter.partial_order.{u_2} α))) (@nhds_within.{u_2} α _inst_1 a s) (@nhds_within.{u_2} α _inst_1 a t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>484      simp [ext_chart_at, local_equiv.trans_target], },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='local_equiv.trans_target'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (e : local_equiv.{?l_1 ?l_2} α β) (e&#x27; : local_equiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_3+1) 1)} (set.{?l_3} γ) (@local_equiv.target.{?l_1 ?l_3} α γ (@local_equiv.trans.{?l_1 ?l_2 ?l_3} α β γ e e&#x27;)) (@has_inter.inter.{?l_3} (set.{?l_3} γ) (@set.has_inter.{?l_3} γ) (@local_equiv.target.{?l_2 ?l_3} β γ e&#x27;) (@set.preimage.{?l_3 ?l_2} γ β (@local_equiv.inv_fun.{?l_2 ?l_3} β γ e&#x27;) (@local_equiv.target.{?l_1 ?l_2} α β e)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@local_equiv.target.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@set.range.{u_2 u_3+1} E H
       (@local_equiv.to_fun.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>485    { apply nhds_within_le_of_mem (ext_chart_at_target_mem_nhds_within _ _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nhds_within_le_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at_target_mem_nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 467, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {a : α} {s t : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s (@nhds_within.{u_2} α _inst_1 a t) → @has_le.le.{u_2} (filter.{u_2} α) (@preorder.to_has_le.{u_2} (filter.{u_2} α) (@partial_order.to_preorder.{u_2} (filter.{u_2} α) (@filter.partial_order.{u_2} α))) (@nhds_within.{u_2} α _inst_1 a t) (@nhds_within.{u_2} α _inst_1 a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E) (@local_equiv.target.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@nhds_within.{u_2} E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x) x) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M
⊢ @has_le.le.{u_2} (filter.{u_2} E)
    (@preorder.to_has_le.{u_2} (filter.{u_2} E)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} E) (@filter.partial_order.{u_2} E)))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x)
       (@local_equiv.target.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>486  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>487  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>488  lemma ext_chart_continuous_at_inv_fun&#x27; {x&#x27; : M} (h : x&#x27; ∈ (ext_chart_at I x).source) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>489    continuous_at (ext_chart_at I x).inv_fun ((ext_chart_at I x).to_fun x&#x27;) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 648, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function between topological spaces is continuous at a point `x₀`
if `f x` tends to `f x₀` when `x` tends to `x₀`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>490  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_4} E M
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_5
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>491    apply continuous_at.comp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous_at.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 661, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] [_inst_3 : topological_space.{u_4} γ] {g : β → γ} {f : α → β} {x : α}, @continuous_at.{u_3 u_4} β γ _inst_2 _inst_3 g (f x) → @continuous_at.{u_2 u_3} α β _inst_1 _inst_2 f x → @continuous_at.{u_2 u_4} α γ _inst_1 _inst_3 (@function.comp.{u_2+1 u_3+1 u_4+1} α β γ g f) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_4} E M
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_5
    (@local_equiv.inv_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_equiv.symm.{u_3 u_4} H M
          (@local_equiv.restr.{u_3 u_4} H M
             (@local_equiv.symm.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
             (@local_equiv.source.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@local_equiv.restr.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x&#x27;))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (λ (x_1 : E),
       @local_equiv.inv_fun.{u_3 u_2} H E
         (@local_equiv.restr.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@local_equiv.target.{u_4 u_3} M H
               (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                  (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
         x_1)
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>492    { simp [ext_chart_at],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_equiv.symm.{u_3 u_4} H M
          (@local_equiv.restr.{u_3 u_4} H M
             (@local_equiv.symm.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
             (@local_equiv.source.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@local_equiv.restr.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x&#x27;))

𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (λ (x_1 : E),
       @local_equiv.inv_fun.{u_3 u_2} H E
         (@local_equiv.restr.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@local_equiv.target.{u_4 u_3} M H
               (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                  (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
         x_1)
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_equiv.symm.{u_3 u_4} H M
          (@local_equiv.restr.{u_3 u_4} H M
             (@local_equiv.symm.{u_4 u_3} M H
                (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                   (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
             (@local_equiv.source.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@local_equiv.inv_fun.{u_3 u_2} H E
       (@local_equiv.restr.{u_3 u_2} H E
          (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
          (@local_equiv.target.{u_4 u_3} M H
             (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>493      rw ext_chart_at_source at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ext_chart_at_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 431, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @eq.{(max (u_4+1) 1)} (set.{u_4} M) (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>494      exact ((chart_at H x).continuous_inv_fun _</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>495        ((chart_at H x).map_source h)).continuous_at</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>496          (mem_nhds_sets (chart_at H x).open_target</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mem_nhds_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : topological_space.{u_3} α] {a : α} {s : set.{u_3} α}, @is_open.{u_3} α _inst_1 s → @has_mem.mem.{u_3 u_3} α (set.{u_3} α) (@set.has_mem.{u_3} α) a s → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) s (@nhds.{u_3} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>497            ((chart_at H x).map_source h)) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='manifold.chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/geometry/manifold/manifold.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (H : Type u_3) [_inst_1 : topological_space.{u_3} H] {M : Type u_4} [_inst_2 : topological_space.{u_4} M] [c : @manifold.{u_3 u_4} H _inst_1 M _inst_2], M → @local_homeomorph.{u_4 u_3} M H _inst_2 _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_3} M H (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4 (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
⊢ @continuous_at.{u_3 u_4} H M _inst_4 _inst_5
    (@local_equiv.inv_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x)))
    (@local_equiv.to_fun.{u_4 u_3} M H
       (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
          (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (λ (x_1 : E),
       @local_equiv.inv_fun.{u_3 u_2} H E
         (@local_equiv.restr.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@local_equiv.target.{u_4 u_3} M H
               (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                  (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
         x_1)
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>498    { exact I.continuous_inv_fun.continuous_at }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
⊢ @continuous_at.{u_2 u_3} E H
    (@uniform_space.to_topological_space.{u_2} E
       (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
    _inst_4
    (λ (x_1 : E),
       @local_equiv.inv_fun.{u_3 u_2} H E
         (@local_equiv.restr.{u_3 u_2} H E
            (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)
            (@local_equiv.target.{u_4 u_3} M H
               (@local_homeomorph.to_local_equiv.{u_4 u_3} M H _inst_5 _inst_4
                  (@manifold.chart_at.{u_3 u_4} H _inst_4 M _inst_5 _inst_6 x))))
         x_1)
    (@local_equiv.to_fun.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
       x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>499  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>500  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>501  lemma ext_chart_continuous_at_inv_fun :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>502    continuous_at (ext_chart_at I x).inv_fun ((ext_chart_at I x).to_fun x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 648, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function between topological spaces is continuous at a point `x₀`
if `f x` tends to `f x₀` when `x` tends to `x₀`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>503  ext_chart_continuous_at_inv_fun&#x27; I x (mem_ext_chart_source I x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ext_chart_continuous_at_inv_fun&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M) {x&#x27; : M}, @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) → @continuous_at.{u_2 u_4} E M (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) _inst_5 (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x) x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>504  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>505  /-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>506  in the source is a neighborhood of the preimage, within a set. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>507  lemma ext_chart_preimage_mem_nhds_within&#x27; {x&#x27; : M} (h : x&#x27; ∈ (ext_chart_at I x).source)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → set.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>508    (ht : t ∈ nhds_within x&#x27; s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>509    (ext_chart_at I x).inv_fun ⁻¹&#x27; t ∈ nhds_within ((ext_chart_at I x).to_fun x&#x27;)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>510      ((ext_chart_at I x).inv_fun ⁻¹&#x27; s ∩ range I.to_fun) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>511  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@set.preimage.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       t)
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x&#x27;)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>512    apply (ext_chart_continuous_at_inv_fun&#x27; I x h).continuous_within_at.tendsto_nhds_within_image,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ext_chart_continuous_at_inv_fun&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 488, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M) {x&#x27; : M}, @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) → @continuous_at.{u_2 u_4} E M (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) _inst_5 (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x) x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@set.preimage.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       t)
    (@nhds_within.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x&#x27;)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds_within.{u_4} M _inst_5
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          (@local_equiv.to_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
             x&#x27;))
       (@set.image.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
             (@set.preimage.{u_2 u_4} E M
                (@local_equiv.inv_fun.{u_4 u_2} M E
                   (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
                s)
             (@set.range.{u_2 u_3+1} E H
                (@local_equiv.to_fun.{u_3 u_2} H E
                   (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>513    rw (ext_chart_at I x).left_inv h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds_within.{u_4} M _inst_5
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          (@local_equiv.to_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
             x&#x27;))
       (@set.image.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
             (@set.preimage.{u_2 u_4} E M
                (@local_equiv.inv_fun.{u_4 u_2} M E
                   (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
                s)
             (@set.range.{u_2 u_3+1} E H
                (@local_equiv.to_fun.{u_3 u_2} H E
                   (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds_within.{u_4} M _inst_5 x&#x27;
       (@set.image.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
             (@set.preimage.{u_2 u_4} E M
                (@local_equiv.inv_fun.{u_4 u_2} M E
                   (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
                s)
             (@set.range.{u_2 u_3+1} E H
                (@local_equiv.to_fun.{u_3 u_2} H E
                   (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>514    apply nhds_within_mono _ _ ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nhds_within_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} [_inst_1 : topological_space.{u_4} α] (a : α) {s t : set.{u_4} α}, @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) s t → @has_le.le.{u_4} (filter.{u_4} α) (@preorder.to_has_le.{u_4} (filter.{u_4} α) (@partial_order.to_preorder.{u_4} (filter.{u_4} α) (@filter.partial_order.{u_4} α))) (@nhds_within.{u_4} α _inst_1 a s) (@nhds_within.{u_4} α _inst_1 a t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds_within.{u_4} M _inst_5 x&#x27;
       (@set.image.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
             (@set.preimage.{u_2 u_4} E M
                (@local_equiv.inv_fun.{u_4 u_2} M E
                   (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
                s)
             (@set.range.{u_2 u_3+1} E H
                (@local_equiv.to_fun.{u_3 u_2} H E
                   (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>515    have : (ext_chart_at I x).inv_fun &#x27;&#x27; ((ext_chart_at I x).inv_fun ⁻¹&#x27; s) ⊆ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_2} α → set.{u_4} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_4} [c : has_subset.{u_4} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>516      image_preimage_subset _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.image_preimage_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1067, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_4} (f : α → β) (s : set.{u_4} β), @has_subset.subset.{u_4} (set.{u_4} β) (@set.has_subset.{u_4} β) (@set.image.{u_2 u_4} α β f (@set.preimage.{u_2 u_4} α β f s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s)
⊢ @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s),
this :
  @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s))
    s
⊢ @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>517    exact subset.trans (image_subset _ (inter_subset_left _ _)) this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.inter_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_4} {a b c : set.{u_4} α}, @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) a b → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) b c → @has_subset.subset.{u_4} (set.{u_4} α) (@set.has_subset.{u_4} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_4} {a b : set.{u_2} α} (f : α → β), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a b → @has_subset.subset.{u_4} (set.{u_4} β) (@set.has_subset.{u_4} β) (@set.image.{u_2 u_4} α β f a) (@set.image.{u_2 u_4} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (s t : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M) (@set.image.{u_2 u_4} E M (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@set.preimage.{u_2 u_4} E M (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M,
x&#x27; : M,
h :
  @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27;
    (@local_equiv.source.{u_4 u_2} M E
       (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)),
ht :
  @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s),
this :
  @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s))
    s
⊢ @has_subset.subset.{u_4} (set.{u_4} M) (@set.has_subset.{u_4} M)
    (@set.image.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>518  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>519  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>520  /-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>521  base point is a neighborhood of the preimage, within a set. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>522  lemma ext_chart_preimage_mem_nhds_within (ht : t ∈ nhds_within x s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>523    (ext_chart_at I x).inv_fun ⁻¹&#x27; t ∈ nhds_within ((ext_chart_at I x).to_fun x)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>524      ((ext_chart_at I x).inv_fun ⁻¹&#x27; s ∩ range I.to_fun) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>525  ext_chart_preimage_mem_nhds_within&#x27; I x (mem_ext_chart_source I x) ht</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ext_chart_preimage_mem_nhds_within&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 507, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M) {s t : set.{u_4} M} {x&#x27; : M}, @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x&#x27; (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) → @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x&#x27; s) → @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E) (@set.preimage.{u_2 u_4} E M (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) t) (@nhds_within.{u_2} E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x) x&#x27;) (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E) (@set.preimage.{u_2 u_4} E M (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) s) (@set.range.{u_2 u_3+1} E H (@local_equiv.to_fun.{u_3 u_2} H E (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds_within.{u_4} M _inst_5 x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point
in the source is a neighborhood of the preimage, within a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>526  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>527  /-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>528  is a neighborhood of the preimage. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>529  lemma ext_chart_preimage_mem_nhds (ht : t ∈ 𝓝 x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_4} [c : has_mem.{u_4 u_4} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} [_inst_1 : topological_space.{u_4} α], α → filter.{u_4} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>530    (ext_chart_at I x).inv_fun ⁻¹&#x27; t ∈ 𝓝 ((ext_chart_at I x).to_fun x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>531  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
t : set.{u_4} M,
ht : @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds.{u_4} M _inst_5 x)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@set.preimage.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       t)
    (@nhds.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>532    apply (ext_chart_continuous_at_inv_fun I x).preimage_mem_nhds,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ext_chart_continuous_at_inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 501, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @continuous_at.{u_2 u_4} E M (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) _inst_5 (@local_equiv.inv_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)) (@local_equiv.to_fun.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
t : set.{u_4} M,
ht : @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds.{u_4} M _inst_5 x)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} E) (filter.{u_2} E) (@filter.has_mem.{u_2} E)
    (@set.preimage.{u_2 u_4} E M
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
       t)
    (@nhds.{u_2} E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@local_equiv.to_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
t : set.{u_4} M,
ht : @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds.{u_4} M _inst_5 x)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds.{u_4} M _inst_5
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          (@local_equiv.to_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>533    rwa (ext_chart_at I x).left_inv (mem_ext_chart_source _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mem_ext_chart_source'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 437, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H] (I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4) {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5] (x : M), @has_mem.mem.{u_4 u_4} M (set.{u_4} M) (@set.has_mem.{u_4} M) x (@local_equiv.source.{u_4 u_2} M E (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
t : set.{u_4} M,
ht : @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t (@nhds.{u_4} M _inst_5 x)
⊢ @has_mem.mem.{u_4 u_4} (set.{u_4} M) (filter.{u_4} M) (@filter.has_mem.{u_4} M) t
    (@nhds.{u_4} M _inst_5
       (@local_equiv.inv_fun.{u_4 u_2} M E
          (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
          (@local_equiv.to_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x)
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>534  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>535  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>536  /-- Technical lemma to rewrite suitably the preimage of an intersection under an extended chart, to</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>537  bring it into a convenient form to apply derivative lemmas. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>538  lemma ext_chart_preimage_inter_eq : ((ext_chart_at I x).inv_fun ⁻¹&#x27; (s ∩ t) ∩ range I.to_fun)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} [c : has_inter.{u_4} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>539    = ((ext_chart_at I x).inv_fun ⁻¹&#x27; s ∩ range (I.to_fun))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='local_equiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {β : Type u_2}, local_equiv.{u_3 u_2} α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>540      ∩ ((ext_chart_at I x).inv_fun ⁻¹&#x27; t) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_4} {β : Type u_2}, local_equiv.{u_4 u_2} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_4}, (α → β) → set.{u_4} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_4} M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>541  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_4} (set.{u_4} M) (@set.has_inter.{u_4} M) s t))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>542    rw [preimage_inter, inter_assoc, inter_assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.preimage_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inter_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 847, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 370, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 370, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_4} {f : α → β} {s t : set.{u_4} β}, @eq.{(max (u_2+1) 1)} (set.{u_2} α) (@set.preimage.{u_2 u_4} α β f (@has_inter.inter.{u_4} (set.{u_4} β) (@set.has_inter.{u_4} β) s t)) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@set.preimage.{u_2 u_4} α β f s) (@set.preimage.{u_2 u_4} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b c : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) c) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b c : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) c) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          (@has_inter.inter.{u_4} (set.{u_4} M) (@set.has_inter.{u_4} M) s t))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t))
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             s)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>543    congr&#x27; 1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{u_2+1} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          s)
       (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
          (@set.range.{u_2 u_3+1} E H
             (@local_equiv.to_fun.{u_3 u_2} H E
                (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
          (@set.preimage.{u_2 u_4} E M
             (@local_equiv.inv_fun.{u_4 u_2} M E
                (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
             t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>544    rw inter_comm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.inter_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} (a b : set.{u_2} α), @eq.{u_2+1} (set.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) a b) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
H : Type u_3,
_inst_4 : topological_space.{u_3} H,
I : @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4,
M : Type u_4,
_inst_5 : topological_space.{u_4} M,
_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5,
x : M,
s t : set.{u_4} M
⊢ @eq.{(max (u_2+1) 1)} (set.{u_2} E)
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I))))
    (@has_inter.inter.{u_2} (set.{u_2} E) (@set.has_inter.{u_2} E)
       (@set.range.{u_2 u_3+1} E H
          (@local_equiv.to_fun.{u_3 u_2} H E
             (@model_with_corners.to_local_equiv.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I)))
       (@set.preimage.{u_2 u_4} E M
          (@local_equiv.inv_fun.{u_4 u_2} M E
             (@ext_chart_at.{u_1 u_2 u_3 u_4} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 I M _inst_5 _inst_6 x))
          t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>545  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>546  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>547  end extended_charts</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>548  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>549  /-- In the case of the manifold structure on a vector space, the extended charts are just the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>550  identity.-/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>551  @[simp] lemma ext_chart_model_space_eq_id (𝕜 : Type*) [nondiscrete_normed_field 𝕜]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='nondiscrete_normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='orange'><a title=' A nondiscrete normed field is a normed field in which there is an element of norm different from
`0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication
by the powers of any element, and thus to relate algebra and topology.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>552    {E : Type*} [normed_group E] [normed_space 𝕜 E] (x : E) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) (β : Type u_2) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{u_2} β], Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>553    ext_chart_at (model_with_corners_self 𝕜 E) x = local_equiv.refl E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='model_with_corners_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='local_equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 133, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/local_equiv.lean&#x27;, &#x27;line&#x27;: 220, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {H : Type u_3} [_inst_4 : topological_space.{u_3} H], @model_with_corners.{u_1 u_2 u_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type u_4} [_inst_5 : topological_space.{u_4} M] [_inst_6 : @manifold.{u_3 u_4} H _inst_4 M _inst_5], M → local_equiv.{u_4 u_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] (E : Type u_2) [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2], @model_with_corners.{u_1 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), local_equiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A vector space is a model with corners.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The identity local equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>554  by simp [ext_chart_at]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ext_chart_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 428, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {𝕜 : Type ?l_1} [_inst_1 : nondiscrete_normed_field.{?l_1} 𝕜] {E : Type ?l_2} [_inst_2 : normed_group.{?l_2} E] [_inst_3 : @normed_space.{?l_1 ?l_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{?l_1} 𝕜 _inst_1) _inst_2] {H : Type ?l_3} [_inst_4 : topological_space.{?l_3} H], @model_with_corners.{?l_1 ?l_2 ?l_3} 𝕜 _inst_1 E _inst_2 _inst_3 H _inst_4 → Π {M : Type ?l_4} [_inst_5 : topological_space.{?l_4} M] [_inst_6 : @manifold.{?l_3 ?l_4} H _inst_4 M _inst_5], M → local_equiv.{?l_4 ?l_2} M E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The preferred extended chart on a manifold with corners around a point `x`, from a neighborhood
of `x` to the model vector space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='𝕜 : Type u_1,
_inst_1 : nondiscrete_normed_field.{u_1} 𝕜,
E : Type u_2,
_inst_2 : normed_group.{u_2} E,
_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2,
x : E
⊢ @eq.{u_2+1} (local_equiv.{u_2 u_2} E E)
    (@ext_chart_at.{u_1 u_2 u_2 u_2} 𝕜 _inst_1 E _inst_2 _inst_3 E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@model_with_corners_self.{u_1 u_2} 𝕜 _inst_1 E _inst_2 _inst_3)
       E
       (@uniform_space.to_topological_space.{u_2} E
          (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2)))
       (@manifold_model_space.{u_2} E
          (@uniform_space.to_topological_space.{u_2} E
             (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))))
       x)
    (local_equiv.refl.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font></pre>
</body>