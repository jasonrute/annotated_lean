<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.eq_to_hom</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/eq_to_hom.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-#</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  Disjoint unions of categories, functors, and natural transformations.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  universes v₁ u₁ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  open sum</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₁) [𝒟 : category.{v₁} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  `sum C D` gives the direct sum of two categories.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  instance sum : category.{v₁} (C ⊕ D) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  { hom :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28      λ X Y, match X, Y with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29      | inl X, inl Y := X ⟶ Y</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30      | inl X, inr Y := pempty</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      | inr X, inl Y := pempty</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32      | inr X, inr Y := X ⟶ Y</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    id :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35      λ X, match X with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      | inl X := 𝟙 X</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      | inr X := 𝟙 X</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    comp :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      λ X Y Z f g, match X, Y, Z, f, g with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41      | inl X, inl Y, inl Z, f, g := f ≫ g</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      | inr X, inr Y, inr Z, f, g := f ≫ g</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43      end }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @[simp] lemma sum_comp_inl {P Q R : C} (f : (inl P : C ⊕ D) ⟶ inl Q) (g : inl Q ⟶ inl R) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    f ≫ g = (f : P ⟶ Q) ≫ (g : Q ⟶ R) := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  @[simp] lemma sum_comp_inr {P Q R : D} (f : (inr P : C ⊕ D) ⟶ inr Q) (g : inr Q ⟶ inr R) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    f ≫ g = (f : P ⟶ Q) ≫ (g : Q ⟶ R) := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  namespace sum</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₁) [𝒟 : category.{v₁} D]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  /-- `inl_` is the functor `X ↦ inl X`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  -- Unfortunate naming here, suggestions welcome.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  @[simps] def inl_ : C ⥤ C ⊕ D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  { obj := λ X, inl X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    map := λ X Y f, f }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  /-- `inr_` is the functor `X ↦ inr X`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  @[simps] def inr_ : D ⥤ C ⊕ D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  { obj := λ X, inr X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    map := λ X Y f, f }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  /-- The functor exchanging two direct summand categories. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  def swap : C ⊕ D ⥤ D ⊕ C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  { obj :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      λ X, match X with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      | inl X := inr X</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72      | inr X := inl X</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    map :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      λ X Y f, match X, Y, f with</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      | inl X, inl Y, f := f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      | inr X, inr Y, f := f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      end }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  @[simp] lemma swap_obj_inl (X : C) : (swap C D).obj (inl X) = inr X := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  @[simp] lemma swap_obj_inr (X : D) : (swap C D).obj (inr X) = inl X := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  @[simp] lemma swap_map_inl {X Y : C} {f : inl X ⟶ inl Y} : (swap C D).map f = f := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  @[simp] lemma swap_map_inr {X Y : D} {f : inr X ⟶ inr Y} : (swap C D).map f = f := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  namespace swap</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  /-- `swap` gives an equivalence between `C ⊕ D` and `D ⊕ C`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  def equivalence : C ⊕ D ≌ D ⊕ C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  equivalence.mk (swap C D) (swap D C)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    (nat_iso.of_components (λ X, eq_to_iso (by { cases X; refl })) (by tidy))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    (nat_iso.of_components (λ X, eq_to_iso (by { cases X; refl })) (by tidy))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  instance is_equivalence : is_equivalence (swap C D) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  (by apply_instance : is_equivalence (equivalence C D).functor)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  /-- The double swap on `C ⊕ D` is naturally isomorphic to the identity functor. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  def symmetry : swap C D ⋙ swap D C ≅ 𝟭 (C ⊕ D) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  (equivalence C D).unit_iso.symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.iso.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π {C : Type (max v₁ u₁)} [𝒞 : category_theory.category.{(max u₁ v₁) (max v₁ u₁)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} C 𝒞 X Y → @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} C 𝒞 Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  end swap</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  end sum</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  variables {A : Type u₁} [𝒜 : category.{v₁} A]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105            {B : Type u₁} [ℬ : category.{v₁} B]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106            {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107            {D : Type u₁} [𝒟 : category.{v₁} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  include 𝒜 ℬ 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  /-- The sum of two functors. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  def sum (F : A ⥤ B) (G : C ⥤ D) : A ⊕ C ⥤ B ⊕ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  { obj :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115      λ X, match X with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116      | inl X := inl (F.obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α β : Type u₁}, α → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      | inr X := inr (G.obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α β : Type u₁}, β → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    map :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      λ X Y f, match X, Y, f with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      | inl X, inl Y, f := F.map f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u₁}, α → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inl.{u₁ u₁} A C X) (@sum.inl.{u₁ u₁} A C Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      | inr X, inr Y, f := G.map f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u₁}, β → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inr.{u₁ u₁} A C X) (@sum.inr.{u₁ u₁} A C Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    map_id&#x27; := λ X, begin cases X; unfold_aux, erw F.map_id, refl, erw G.map_id, refl end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : A), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} B (@category_theory.category_struct.to_has_hom.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X X (@category_theory.category_struct.id.{v₁ u₁} A (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜) X)) (@category_theory.category_struct.id.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X X (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X)) (@category_theory.category_struct.id.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Unfold auxiliary definitions associated with the current declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : sum.{u₁ u₁} A C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G X)
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G X))
    (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G X X
       (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
          X))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : A
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} B
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
             (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X X
          (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inl.{u₁ u₁} A C X))))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))))

A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X X
          (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inr.{u₁ u₁} A C X))))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : A
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} B
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
             (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))
       (@category_theory.category_struct.id.{v₁ u₁} B
          (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X))))

A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X X
          (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inr.{u₁ u₁} A C X))))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X X
          (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inr.{u₁ u₁} A C X))))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))
       (@category_theory.category_struct.id.{v₁ u₁} D
          (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
    (@category_theory.category_struct.id.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    map_comp&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      λ X Y Z f g, match X, Y, Z, f, g with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      | inl X, inl Y, inl Z, f, g := by { unfold_aux, erw F.map_comp, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {α β : Type u₁}, α → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} A (@category_theory.category_struct.to_has_hom.{v₁ u₁} A (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} A (@category_theory.category_struct.to_has_hom.{v₁ u₁} A (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} B (@category_theory.category_struct.to_has_hom.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Z (@category_theory.category_struct.comp.{v₁ u₁} A (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜) X Y Z f g)) (@category_theory.category_struct.comp.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Y f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Unfold auxiliary definitions associated with the current declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='unfold_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C Y)
    (@sum.inl.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C Z)))
    (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C X)
       (@sum.inl.{u₁ u₁} A C Z)
       (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          (@sum.inl.{u₁ u₁} A C Z)
          f
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C Z))
       (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f)
       (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inl.{u₁ u₁} A C Y)
          (@sum.inl.{u₁ u₁} A C Z)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C Y)
    (@sum.inl.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} B
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
             (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Z
          (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inl.{u₁ u₁} A C X)
             (@sum.inl.{u₁ u₁} A C Y)
             (@sum.inl.{u₁ u₁} A C Z)
             f
             g)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z)))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Y f))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C Y)
    (@sum.inl.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} B
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
             (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))
       (@category_theory.category_struct.comp.{v₁ u₁} B
          (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Y f)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y Z g)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inl.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z)))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Y f))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Z))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      | inr X, inr Y, inr Z, f, g := by { unfold_aux, erw G.map_comp, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {α β : Type u₁}, β → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Z (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X Y Z f g)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Unfold auxiliary definitions associated with the current declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='unfold_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C Y)
    (@sum.inr.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C Z)))
    (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C X)
       (@sum.inr.{u₁ u₁} A C Z)
       (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          (@sum.inr.{u₁ u₁} A C Z)
          f
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C Z))
       (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f)
       (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G (@sum.inr.{u₁ u₁} A C Y)
          (@sum.inr.{u₁ u₁} A C Z)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C Y)
    (@sum.inr.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Z
          (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
                (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
             (@sum.inr.{u₁ u₁} A C X)
             (@sum.inr.{u₁ u₁} A C Y)
             (@sum.inr.{u₁ u₁} A C Z)
             f
             g)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z)))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
X Y Z : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    Y
    Z,
_match :
  ∀ (_a _a_1 _a_2 : sum.{u₁ u₁} A C)
  (_a_3 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1)
  (_a_4 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a_1
      _a_2),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2))
      (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_2
         (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
               (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))
            _a
            _a_1
            _a_2
            _a_3
            _a_4))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1)
         (@category_theory.functor.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_2)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a _a_1 _a_3)
         (@category_theory.functor.sum._match_2.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G _a_1 _a_2 _a_4)),
X Y Z : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y),
g :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C Y)
    (@sum.inr.{u₁ u₁} A C Z)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))))
    (id_rhs.{v₁+1}
       (@category_theory.has_hom.hom.{v₁ u₁} D
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
             (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))
       (@category_theory.category_struct.comp.{v₁ u₁} D
          (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y Z g)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)))
       (id_rhs.{u₁+1} (sum.{u₁ u₁} B D)
          (@sum.inr.{u₁ u₁} B D (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z)))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Z))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y Z g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129      end }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  @[simp] lemma sum_obj_inl (F : A ⥤ B) (G : C ⥤ D) (a : A) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    (F.sum G).obj (inl a) = inl (F.obj a) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u₁} {a : α}, @eq.{u₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  @[simp] lemma sum_obj_inr (F : A ⥤ B) (G : C ⥤ D) (c : C) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    (F.sum G).obj (inr c) = inr (G.obj c) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u₁} {a : α}, @eq.{u₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  @[simp] lemma sum_map_inl (F : A ⥤ B) (G : C ⥤ D) {a a&#x27; : A} (f : inl a ⟶ inl a&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    (F.sum G).map f = F.map f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inl.{u₁ u₁} A C a) (@sum.inl.{u₁ u₁} A C a&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inl.{u₁ u₁} A C a) (@sum.inl.{u₁ u₁} A C a&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  @[simp] lemma sum_map_inr (F : A ⥤ B) (G : C ⥤ D) {c c&#x27; : C} (f : inr c ⟶ inr c&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    (F.sum G).map f = G.map f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inr.{u₁ u₁} A C c) (@sum.inr.{u₁ u₁} A C c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) (@sum.inr.{u₁ u₁} A C c) (@sum.inr.{u₁ u₁} A C c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  namespace nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  /-- The sum of two natural transformations. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  def sum {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) : F.sum H ⟶ G.sum I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The sum of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  { app         :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146      λ X, match X with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      | inl X := α.app X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α β : Type u₁}, α → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148      | inr X := β.app X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α β : Type u₁}, β → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149      end,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151      λ X Y f, match X, Y, f with</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='sum.{u₁ u₁} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      | inl X, inl Y, f := begin unfold_aux, erw α.naturality, refl, end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u₁}, α → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ ⦃X Y : A⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} A (@category_theory.category_struct.to_has_hom.{v₁ u₁} A (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} B (@category_theory.category_struct.to_has_hom.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G Y)) (@category_theory.category_struct.comp.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G Y) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X Y f) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α Y)) (@category_theory.category_struct.comp.{v₁ u₁} B (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Unfold auxiliary definitions associated with the current declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='unfold_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f)
       (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β
          (@sum.inl.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f)
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G Y))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : A,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inl.{u₁ u₁} A C X)
    (@sum.inl.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} B
       (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α X)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X Y f))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C Y))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} B
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} B
                (@category_theory.category.to_category_struct.{v₁ u₁} B ℬ))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ G X))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ F G α X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inl.{u₁ u₁} A C X)
          (@sum.inl.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      | inr X, inr Y, f := begin unfold_aux, erw β.naturality, refl, end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α β : Type u₁}, β → sum.{u₁ u₁} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I Y) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X Y f) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Unfold auxiliary definitions associated with the current declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='unfold_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f)
       (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β
          (@sum.inr.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f)
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H Y)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I Y))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₁,
ℬ : category_theory.category.{v₁ u₁} B,
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₁,
𝒟 : category_theory.category.{v₁ u₁} D,
F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)}
    (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)}
       (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)}
          (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟)))
    H
    I,
X Y : sum.{u₁ u₁} A C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    X
    Y,
_match :
  ∀ (_a _a_1 : sum.{u₁ u₁} A C)
  (_a_2 :
    @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
      _a
      _a_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
               (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a
            _a_1
            _a_2)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a_1))
      (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
         (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a_1)
         (@category_theory.nat_trans.sum._match_1.{u₁ v₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F G H I α β _a)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
            (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
            (sum.{u₁ u₁} B D)
            (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
            (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
            _a
            _a_1
            _a_2)),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} A C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} A C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)))
    (@sum.inr.{u₁ u₁} A C X)
    (@sum.inr.{u₁ u₁} A C Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
             (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y)))
    (@category_theory.category_struct.comp.{v₁ u₁} D
       (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β X)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X Y f))
    (@category_theory.category_struct.comp.{v₁ u₁} (sum.{u₁ u₁} B D)
       (@category_theory.category.to_category_struct.{v₁ u₁} (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C Y))
       (id_rhs.{v₁+1}
          (@category_theory.has_hom.hom.{v₁ u₁} D
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} D
                (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 I X))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 H I β X))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C)
          (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞)
          (sum.{u₁ u₁} B D)
          (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)
          (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@sum.inr.{u₁ u₁} A C X)
          (@sum.inr.{u₁ u₁} A C Y)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      end }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  @[simp] lemma sum_app_inl {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (a : A) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    (sum α β).app (inl a) = α.app a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sum.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ} {H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))) (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H) (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, α → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The sum of two natural transformations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  @[simp] lemma sum_app_inr {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (c : C) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    (sum α β).app (inr c) = β.app c := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='sum.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₁} [ℬ : category_theory.category.{v₁ u₁} B] {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ} {H I : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} (sum.{u₁ u₁} A C) (@category_theory.sum.{v₁ u₁} A 𝒜 C 𝒞) (sum.{u₁ u₁} B D) (@category_theory.sum.{v₁ u₁} B ℬ D 𝒟)))) (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 F H) (@category_theory.functor.sum.{v₁ u₁} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} A 𝒜 B ℬ))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, β → sum.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟))) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The sum of two natural transformations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  end nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  end category_theory</code></pre>
</body>