<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Stephen Morgan, Scott Morrison, Floris van Doorn</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.const</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.yoneda</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.concrete_category.bundled_hom</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/bundled_hom.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  universes v u u&#x27; -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  -- There is an awkward difficulty with universes here.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  -- If we allowed `J` to be a small category in `Prop`, we&#x27;d run into trouble</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  -- because `yoneda.obj (F : (J ⥤ C)ᵒᵖ)` will be a functor into `Sort (max v 1)`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  -- not into `Sort v`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  -- So we don&#x27;t allow this case; it&#x27;s not particularly useful anyway.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  variables {J : Type v} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  variables {C : Type u} [𝒞 : category.{v} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  open category_theory.category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  open category_theory.functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  variables {J C} (F : J ⥤ C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  `F.cones` is the functor assigning to an object `X` the type of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  natural transformations from the constant functor with value `X` to `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  An object representing this functor is a limit of `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  def cones : Cᵒᵖ ⥤ Type v := (const J).op ⋙ (yoneda.obj F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type (v+1)) [_inst_2 : category_theory.category.{v v+1} D], Type (max v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (max v u)} [𝒟 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C 𝒞 D 𝒟 → @category_theory.functor.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} D) (@category_theory.category.opposite.{v (max v u)} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (max v u)} [𝒟 : category_theory.category.{v (max v u)} D] {E : Type (v+1)} [ℰ : category_theory.category.{v v+1} E], @category_theory.functor.{v v u (max v u)} C 𝒞 D 𝒟 → @category_theory.functor.{v v (max v u) v+1} D 𝒟 E ℰ → @category_theory.functor.{v v u v+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max v u)} [𝒞 : category_theory.category.{v (max v u)} C], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C 𝒞 (@category_theory.functor.{v v (max v u) v+1} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v (max v u) v+1} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {D : Type (max v (max v u) (v+1))} [_inst_2 : category_theory.category.{(max v u) (max v (max v u) (v+1))} D], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  lemma cones_obj (X : Cᵒᵖ) : F.cones.obj X = ((const J).obj (unop X) ⟶ F) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type (v+1)} {a : α}, @eq.{v+2} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  @[simp] lemma cones_map_app {X₁ X₂ : Cᵒᵖ} (f : X₁ ⟶ X₂) (t : F.cones.obj X₁) (j : J) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    (F.cones.map f t).app j = f.unop ≫ t.app j := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D] (c : @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D _inst_2)) (@category_theory.functor.obj.{v v u v+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u v+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) X₁ X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) X₁ X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C}, @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y → @category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  `F.cocones` is the functor assigning to an object `X` the type of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  natural transformations from `F` to the constant functor with value `X`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  An object corepresenting this functor is a colimit of `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  def cocones : C ⥤ Type v := const J ⋙ coyoneda.obj (op F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type (v+1)) [_inst_2 : category_theory.category.{v v+1} D], Type (max v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (max v u)} [𝒟 : category_theory.category.{v (max v u)} D] {E : Type (v+1)} [ℰ : category_theory.category.{v v+1} E], @category_theory.functor.{v v u (max v u)} C 𝒞 D 𝒟 → @category_theory.functor.{v v (max v u) v+1} D 𝒟 E ℰ → @category_theory.functor.{v v u v+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v u)} [𝒞 : category_theory.category.{v (max v u)} C], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (@category_theory.functor.{v v (max v u) v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v (max v u) v+1} C 𝒞 (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {D : Type (max v (max v u) (v+1))} [_inst_2 : category_theory.category.{(max v u) (max v (max v u) (v+1))} D], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
X : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
             (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})
             (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (Type v)
                category_theory.types.{v})))
       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 X)
       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 X))
    (@category_theory.whisker_left.{u v (max v u) v v+1 v} (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
       (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
       (Type v)
       category_theory.types.{v}
       (@category_theory.functor.op.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞))
       (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))}
          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.yoneda.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          X)
       (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))}
          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.yoneda.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          X)
       (@category_theory.functor.map.{v (max v u) (max v u) (max v (max v u) (v+1))}
          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v (max v u) v+1}
             (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞))
             (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             (Type v)
             category_theory.types.{v})
          (@category_theory.yoneda.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          X
          X
          (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.category.to_category_struct.{v (max v u)}
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             X)))
    (@category_theory.category_struct.id.{(max u v) (max v u (v+1))}
       (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
          (Type v)
          category_theory.types.{v})
       (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))}
          (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v})
          (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (Type v)
             category_theory.types.{v}))
       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  lemma cocones_obj (X : C) : F.cocones.obj X = (F ⟶ (const J).obj X) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (v+1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type (v+1)} {a : α}, @eq.{v+2} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  @[simp] lemma cocones_map_app {X₁ X₂ : C} (f : X₁ ⟶ X₂) (t : F.cocones.obj X₁) (j : J) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    (F.cocones.map f t).app j = t.app j ≫ f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D] (c : @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D _inst_2)) (@category_theory.functor.obj.{v v u v+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u v+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X₁ X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X₁ X₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  variables (J C)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  Functorially associated to each functor `J ⥤ C`, we have the `C`-presheaf consisting of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  cones with a given cone point.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simps] def cones : (J ⥤ C) ⥤ (Cᵒᵖ ⥤ Type v) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (max v u)) [_inst_1 : category_theory.category.{v (max v u)} C] (D : Type (max v u (v+1))) [_inst_2 : category_theory.category.{(max u v) (max v u (v+1))} D], Type (max v (max u v) (max v u) v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type (v+1)) [_inst_2 : category_theory.category.{v v+1} D], Type (max v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  { obj := functor.cones,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    map := λ F G f, whisker_left (const J).op (yoneda.map f) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (max v u)} [𝒟 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C 𝒞 D 𝒟 → @category_theory.functor.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (opposite.{(max v u)+1} D) (@category_theory.category.opposite.{v (max v u)} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v u)} [𝒞 : category_theory.category.{v (max v u)} C], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C 𝒞 (@category_theory.functor.{v v (max v u) v+1} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v (max v u) v+1} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {D : Type (max v (max v u) (v+1))} [_inst_2 : category_theory.category.{(max v u) (max v (max v u) (v+1))} D] (c : @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max v u) (max v (max v u) (v+1))} D (@category_theory.category_struct.to_has_hom.{(max v u) (max v (max v u) (v+1))} D (@category_theory.category.to_category_struct.{(max v u) (max v (max v u) (v+1))} D _inst_2)) (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  Contravariantly associated to each functor `J ⥤ C`, we have the `C`-copresheaf consisting of</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  cocones with a given cocone point.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  @[simps] def cocones : (J ⥤ C)ᵒᵖ ⥤ (C ⥤ Type v) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (max v u) → Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max v u)) [_inst_1 : category_theory.category.{v (max v u)} C] (D : Type (max v u (v+1))) [_inst_2 : category_theory.category.{(max u v) (max v u (v+1))} D], Type (max v (max u v) (max v u) v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type (v+1)) [_inst_2 : category_theory.category.{v v+1} D], Type (max v u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  { obj := λ F, functor.cocones (unop F),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    map := λ F G f, whisker_left (const J) (coyoneda.map f) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category_struct.to_has_hom.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category.to_category_struct.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v u)} [𝒞 : category_theory.category.{v (max v u)} C], @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} (opposite.{(max v u)+1} C) (@category_theory.category.opposite.{v (max v u)} C 𝒞) (@category_theory.functor.{v v (max v u) v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v (max v u) v+1} C 𝒞 (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {D : Type (max v (max v u) (v+1))} [_inst_2 : category_theory.category.{(max v u) (max v (max v u) (v+1))} D] (c : @category_theory.functor.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max v u) (max v (max v u) (v+1))} D (@category_theory.category_struct.to_has_hom.{(max v u) (max v (max v u) (v+1))} D (@category_theory.category.to_category_struct.{(max v u) (max v (max v u) (v+1))} D _inst_2)) (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v (max v u) (max v u) (max v (max v u) (v+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category_struct.to_has_hom.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category.to_category_struct.{v (max v u)} (opposite.{(max v u)+1} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)) (@category_theory.category.opposite.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  namespace limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  A `c : cone F` is:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  * an object `c.X` and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  * a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  `cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  structure cone (F : J ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  (X : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  (π : (const J).obj X ⟶ F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  @[simp] lemma cone.w {F : J ⥤ C} (c : cone F) {j j&#x27; : J} (f : j ⟶ j&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    c.π.app j ≫ F.map f = c.π.app j&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D] (c : @category_theory.functor.{v v v u} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v v} C (@category_theory.category_struct.to_has_hom.{v v} C (@category_theory.category.to_category_struct.{v v} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D _inst_2)) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  by convert ←(c.π.naturality f).symm; apply id_comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u) [c : category_theory.category.{v u} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X X Y (@category_theory.category_struct.id.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c)
          j)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c)
       j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c)
          j)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c)
       j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  A `c : cocone F` is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  * an object `c.X` and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  * a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  `cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  structure cocone (F : J ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  (X : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  (ι : F ⟶ (const J).obj X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D], @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  @[simp] lemma cocone.w {F : J ⥤ C} (c : cocone F) {j j&#x27; : J} (f : j ⟶ j&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type v} [c : category_theory.has_hom.{v v} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    F.map f ≫ c.ι.app j&#x27; = c.ι.app j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [_inst_1 : category_theory.category.{v v} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D] (c : @category_theory.functor.{v v v u} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v v} C (@category_theory.category_struct.to_has_hom.{v v} C (@category_theory.category.to_category_struct.{v v} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D _inst_2)) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v v u} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  by convert ←(c.ι.naturality f); apply comp_id</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v v} J (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u) [c : category_theory.category.{v u} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X Y Y f (@category_theory.category_struct.id.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
          j&#x27;))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
          j&#x27;))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
j j&#x27; : J,
f :
  @category_theory.has_hom.hom.{v v} J
    (@category_theory.category_struct.to_has_hom.{v v} J (@category_theory.category.to_category_struct.{v v} J _inst_1))
    j
    j&#x27;
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j&#x27;)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          j&#x27;)
       (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F j j&#x27; f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
          j&#x27;))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  variables {F : J ⥤ C}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  namespace cone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  def equiv (F : J ⥤ C) : cone F ≅ Σ X, F.cones.obj X :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max (u+1) (v+1))} [_inst_1 : category_theory.category.{(max u v) (max (u+1) (v+1))} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  { hom := λ c, ⟨op c.X, c.π⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    inv := λ c, { X := unop c.1, π := c.2 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@sigma.{u v} (opposite.{u+1} C) (λ (X : opposite.{u+1} C), @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@sigma.{u v} (opposite.{u+1} C) (λ (X : opposite.{u+1} C), @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type v}, @sigma.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@sigma.{u v} (opposite.{u+1} C) (λ (X : opposite.{u+1} C), @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type v} (c : @sigma.{u v} α β), β (@sigma.fst.{u v} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    hom_inv_id&#x27; := begin ext, cases x, refl, end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category_struct.to_has_hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
             category_theory.types.{(max u v)}))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ @eq.{(max (u+1) (v+1))} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       x)
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x_X : C,
x_π :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
       x_X)
    F
⊢ @eq.{(max (u+1) (v+1))} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F x_X x_π))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F x_X x_π))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    inv_hom_id&#x27; := begin ext, cases x, refl, end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@sigma.{u v} (opposite.{u+1} C) (λ (X : opposite.{u+1} C), @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category_struct.to_has_hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
             category_theory.types.{(max u v)}))
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X)))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c)))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x :
  @sigma.{u v} (opposite.{u+1} C)
    (λ (X : opposite.{u+1} C),
       @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
         (Type v)
         category_theory.types.{v}
         (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
         X)
⊢ @eq.{(max (u+1) (v+1))}
    (@sigma.{u v} (opposite.{u+1} C)
       (λ (X : opposite.{u+1} C),
          @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
            (Type v)
            category_theory.types.{v}
            (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
            X))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c))
       x)
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x_fst : opposite.{u+1} C,
x_snd :
  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v)
    category_theory.types.{v}
    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
    x_fst
⊢ @eq.{(max (u+1) (v+1))}
    (@sigma.{u v} (opposite.{u+1} C)
       (λ (X : opposite.{u+1} C),
          @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
            (Type v)
            category_theory.types.{v}
            (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
            X))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 F
            (@opposite.unop.{u+1} C
               (@sigma.fst.{u v} (opposite.{u+1} C)
                  (λ (X : opposite.{u+1} C),
                     @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                       (@category_theory.category.opposite.{v u} C 𝒞)
                       (Type v)
                       category_theory.types.{v}
                       (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                       X)
                  c))
            (@sigma.snd.{u v} (opposite.{u+1} C)
               (λ (X : opposite.{u+1} C),
                  @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                    (@category_theory.category.opposite.{v u} C 𝒞)
                    (Type v)
                    category_theory.types.{v}
                    (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} (opposite.{u+1} C)
            (λ (X : opposite.{u+1} C),
               @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
                 (@category_theory.category.opposite.{v u} C 𝒞)
                 (Type v)
                 category_theory.types.{v}
                 (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@opposite.op.{u+1} C (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c))
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c))
       (@sigma.mk.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X)
          x_fst
          x_snd))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@sigma.mk.{u v} (opposite.{u+1} C)
          (λ (X : opposite.{u+1} C),
             @category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (Type v)
               category_theory.types.{v}
               (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)
               X)
          x_fst
          x_snd))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  @[simp] def extensions (c : cone F) : yoneda.obj c.X ⟶ F.cones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v (max u v) u (max v u (v+1))} C 𝒞 (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u (v+1))} [_inst_2 : category_theory.category.{(max u v) (max v u (v+1))} D], @category_theory.functor.{v (max u v) u (max v u (v+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u (v+1))} [c : category_theory.has_hom.{(max u v) (max v u (v+1))} obj], obj → obj → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`F.cones` is the functor assigning to an object `X` the type of
natural transformations from the constant functor with value `X` to `F`.
An object representing this functor is a limit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  { app := λ X f, ((const J).map f) ≫ c.π }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} C 𝒞 (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.yoneda.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D] (c : @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v (max v u)} D (@category_theory.category_struct.to_has_hom.{v (max v u)} D (@category_theory.category.to_category_struct.{v (max v u)} D _inst_2)) (@category_theory.functor.obj.{v v u (max v u)} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u (max v u)} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v} (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} C 𝒞 (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.yoneda.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  /-- A map to the vertex of a cone induces a cone by composition. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  @[simp] def extend (c : cone F) {X : C} (f : X ⟶ c.X) : cone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  { X := X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    π := c.extensions.app (op X) f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.extensions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}))) (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} C 𝒞 (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.yoneda.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {F G : @category_theory.functor.{v v u v+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v u v+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D 𝒟)) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  @[simp] lemma extend_π  (c : cone F) {X : Cᵒᵖ} (f : unop X ⟶ c.X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    (extend c f).π = c.extensions.app X f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cone.extend'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.extensions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 128, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 124, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) {X : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) → @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@opposite.unop.{u+1} C X) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}))) (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} C 𝒞 (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.yoneda.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.functor.cones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {F G : @category_theory.functor.{v v u v+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v u v+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D 𝒟)) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@opposite.unop.{u+1} C X) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A map to the vertex of a cone induces a cone by composition.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  @[simps] def whisker {K : Type v} [small_category K] (E : K ⥤ J) (c : cone F) : cone (E ⋙ F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type v → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type v) [_inst_2 : category_theory.category.{v v} D], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v v} K _inst_2 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type v} [𝒟 : category_theory.category.{v v} D] {E : Type u} [ℰ : category_theory.category.{v u} E], @category_theory.functor.{v v v v} C 𝒞 D 𝒟 → @category_theory.functor.{v v v u} D 𝒟 E ℰ → @category_theory.functor.{v v v u} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  { X := c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    π := whisker_left E c.π }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v v} K _inst_2 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  -- We now prove a lemma about naturality of cones over functors into bundled categories.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  omit 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  variables {J&#x27; : Type u} [small_category J&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} C&#x27; (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27; (@category_theory.category.to_category_struct.{u u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))) (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G s) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  variables {C&#x27; : Type (u+1)} [𝒞&#x27; : concrete_category C&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='category_theory.concrete_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A concrete category is a category `C` with a fixed faithful functor `forget : C ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  include 𝒞&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  local attribute [instance] concrete_category.has_coe_to_sort</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.concrete_category.has_coe_to_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], has_coe_to_sort.{u+2 u+2} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Provide a coercion to `Type u` for a concrete category. This is not marked as an instance
as it could potentially apply to every type, and so is too expensive in typeclass search.

You can use it on particular examples as:
```lean
instance : has_coe_to_sort X := concrete_category.has_coe_to_sort X
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  local attribute [instance] concrete_category.has_coe_to_fun</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.concrete_category.has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} C] {X Y : C}, has_coe_to_fun.{u+1 u+1} (@category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1))) X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Usually a bundled hom structure already has a coercion to function
that works with different universes. So we don&#x27;t use this as a global instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  /-- Naturality of a cone over functors to a concrete category. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  @[simp] lemma naturality_concrete {G : J&#x27; ⥤ C&#x27;} (s : cone G) {j j&#x27; : J&#x27;} (f : j ⟶ j&#x27;) (x : s.X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{u u} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153     (G.map f) ((s.π.app j) x) = (s.π.app j&#x27;) x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J&#x27; (@category_theory.category_struct.to_has_hom.{u u} J&#x27; (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{u u+1} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{u u+1} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s : @category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       s)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j
          j&#x27;
          f)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          G
          (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    convert congr_fun (congr_arg (λ k : s.X ⟶ G.obj j&#x27;, (k : s.X → G.obj j&#x27;)) (s.π.naturality f).symm) x;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : α → Type u} {f g : Π (x : α), β x}, @eq.{u+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{u+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} {a₁ a₂ : α} (f : α → β), @eq.{u+1} α a₁ a₂ → @eq.{u+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J&#x27; (@category_theory.category_struct.to_has_hom.{u u} J&#x27; (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s : @category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       s)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j
          j&#x27;
          f)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          G
          (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    { dsimp, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s : @category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       s)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j
          j&#x27;
          f)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          G
          (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s : @category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       s)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j
          j&#x27;
          f)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                   (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                      (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                      G
                      s))
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.category_struct.comp.{u u+1} C&#x27;
          (@category_theory.category.to_category_struct.{u u+1} C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s : @category_theory.limits.cone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       s)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          j
          j&#x27;
          f)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j))
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;))
       (@category_theory.category_struct.comp.{u u+1} C&#x27;
          (@category_theory.category.to_category_struct.{u u+1} C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
          (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             G
             (@category_theory.limits.cone.π.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j)
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end cone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  namespace cocone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  def equiv (F : J ⥤ C) : cocone F ≅ Σ X, F.cocones.obj X :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max (u+1) (v+1))} [_inst_1 : category_theory.category.{(max u v) (max (u+1) (v+1))} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Type v) → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (v+1)} [_inst_2 : category_theory.category.{v v+1} D], @category_theory.functor.{v v u v+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  { hom := λ c, ⟨c.X, c.ι⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    inv := λ c, { X := c.1, ι := c.2 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='sigma.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@sigma.{u v} C (λ (X : C), @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@sigma.{u v} C (λ (X : C), @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type v}, @sigma.{u v} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@sigma.{u v} C (λ (X : C), @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : α → Type v} (c : @sigma.{u v} α β), β (@sigma.fst.{u v} α β c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    hom_inv_id&#x27; := begin ext, cases x, refl, end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category_struct.to_has_hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
             category_theory.types.{(max u v)}))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ @eq.{(max (u+1) (v+1))} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       x)
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x_X : C,
x_ι :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
       x_X)
⊢ @eq.{(max (u+1) (v+1))} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (@category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F x_X x_ι))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F x_X x_ι))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    inv_hom_id&#x27; := begin ext, cases x, refl, end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@sigma.{u v} C (λ (X : C), @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @eq.{(max u v)+1}
    (@category_theory.has_hom.hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category_struct.to_has_hom.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
             category_theory.types.{(max u v)}))
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X)))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c)))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x :
  @sigma.{u v} C
    (λ (X : C),
       @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
         (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
         X)
⊢ @eq.{(max (u+1) (v+1))}
    (@sigma.{u v} C
       (λ (X : C),
          @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
            (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
            X))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c))
       x)
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
x_fst : C,
x_snd :
  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
    x_fst
⊢ @eq.{(max (u+1) (v+1))}
    (@sigma.{u v} C
       (λ (X : C),
          @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
            (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
            X))
    (@category_theory.category_struct.comp.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (λ
        (c :
          @sigma.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)),
          @category_theory.limits.cocone.mk.{v u} J _inst_1 C 𝒞 F
            (@sigma.fst.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c)
            (@sigma.snd.{u v} C
               (λ (X : C),
                  @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                    (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                    X)
               c))
       (λ (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @sigma.mk.{u v} C
            (λ (X : C),
               @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
                 (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
                 X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c))
       (@sigma.mk.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X)
          x_fst
          x_snd))
    (@category_theory.category_struct.id.{(max u v) (max (u+1) (v+1))} (Type (max u v))
       (@category_theory.category.to_category_struct.{(max u v) (max (u+1) (v+1))} (Type (max u v))
          category_theory.types.{(max u v)})
       (@sigma.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X))
       (@sigma.mk.{u v} C
          (λ (X : C),
             @category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}
               (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)
               X)
          x_fst
          x_snd))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  @[simp] def extensions (c : cocone F) : coyoneda.obj (op c.X) ⟶ F.cocones :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.cocones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/yoneda.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v (max u v) u (max v u (v+1))} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u (v+1))} [_inst_2 : category_theory.category.{(max u v) (max v u (v+1))} D], @category_theory.functor.{v (max u v) u (max v u (v+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u (v+1))} [c : category_theory.has_hom.{(max u v) (max v u (v+1))} obj], obj → obj → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → @category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`F.cocones` is the functor assigning to an object `X` the type of
natural transformations from `F` to the constant functor with value `X`.
An object corepresenting this functor is a colimit of `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  { app := λ X f, c.ι ≫ (const J).map f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.coyoneda.{v u} C 𝒞) (@opposite.op.{u+1} C (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type u₁) [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type (max v u)} [_inst_2 : category_theory.category.{v (max v u)} D] (c : @category_theory.functor.{v v u (max v u)} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v (max v u)} D (@category_theory.category_struct.to_has_hom.{v (max v u)} D (@category_theory.category.to_category_struct.{v (max v u)} D _inst_2)) (@category_theory.functor.obj.{v v u (max v u)} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u (max v u)} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v} (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.coyoneda.{v u} C 𝒞) (@opposite.op.{u+1} C (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  /-- A map from the vertex of a cocone induces a cocone by composition. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  @[simp] def extend (c : cocone F) {X : C} (f : c.X ⟶ X) : cocone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  { X := X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    ι := c.extensions.app X f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.extensions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}))) (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.coyoneda.{v u} C 𝒞) (@opposite.op.{u+1} C (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {F G : @category_theory.functor.{v v u v+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v u v+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D 𝒟)) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  @[simp] lemma extend_ι  (c : cocone F) {X : C} (f : c.X ⟶ X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    (extend c f).ι = c.extensions.app X f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cocone.extend'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.extensions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 175, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) {X : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) X → @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}))) (@category_theory.functor.obj.{v (max u v) u (max v u (v+1))} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} C 𝒞 (Type v) category_theory.types.{v}) (@category_theory.coyoneda.{v u} C 𝒞) (@opposite.op.{u+1} C (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.functor.cocones.{v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {F G : @category_theory.functor.{v v u v+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v u v+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D 𝒟)) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A map from the vertex of a cocone induces a cocone by composition.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  @[simps] def whisker {K : Type v} [small_category K] (E : K ⥤ J) (c : cocone F) : cocone (E ⋙ F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='K'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type v → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type v) [_inst_2 : category_theory.category.{v v} D], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v v} K _inst_2 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type v} [𝒟 : category_theory.category.{v v} D] {E : Type u} [ℰ : category_theory.category.{v u} E], @category_theory.functor.{v v v v} C 𝒞 D 𝒟 → @category_theory.functor.{v v v u} D 𝒟 E ℰ → @category_theory.functor.{v v v u} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  { X := c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    ι := whisker_left E c.ι }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v v} K _inst_2 J _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  -- We now prove a lemma about naturality of cocones over functors into bundled categories.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  omit 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  variables {J&#x27; : Type u} [small_category J&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.has_hom.hom.{u u+1} C&#x27; (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27; (@category_theory.category.to_category_struct.{u u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j) (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  variables {C&#x27; : Type (u+1)} [𝒞&#x27; : concrete_category C&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='category_theory.concrete_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type (u+1) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='A concrete category is a category `C` with a fixed faithful functor `forget : C ⥤ Type`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  include 𝒞&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  local attribute [instance] concrete_category.has_coe_to_sort</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.concrete_category.has_coe_to_sort'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (C : Type (u+1)) [_inst_1 : category_theory.concrete_category.{u} C], has_coe_to_sort.{u+2 u+2} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Provide a coercion to `Type u` for a concrete category. This is not marked as an instance
as it could potentially apply to every type, and so is too expensive in typeclass search.

You can use it on particular examples as:
```lean
instance : has_coe_to_sort X := concrete_category.has_coe_to_sort X
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  local attribute [instance] concrete_category.has_coe_to_fun</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.concrete_category.has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type (u+1)} [_inst_1 : category_theory.concrete_category.{u} C] {X Y : C}, has_coe_to_fun.{u+1 u+1} (@category_theory.has_hom.hom.{u u+1} C (@category_theory.category_struct.to_has_hom.{u u+1} C (@category_theory.category.to_category_struct.{u u+1} C (@category_theory.concrete_category.to_category.{u} C _inst_1))) X Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Usually a bundled hom structure already has a coercion to function
that works with different universes. So we don&#x27;t use this as a global instance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  /-- Naturality of a cocone over functors into a concrete category. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  @[simp] lemma naturality_concrete {G : J&#x27; ⥤ C&#x27;} (s : cocone G) {j j&#x27; : J&#x27;} (f : j ⟶ j&#x27;) (x : G.obj j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{u u} C] (D : Type (u+1)) [_inst_2 : category_theory.category.{u u+1} D], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{u u} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D], @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199    (s.ι.app j&#x27;) ((G.map f) x) = (s.ι.app j) x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{u u} C] {D : Type (u+1)} [_inst_2 : category_theory.category.{u u+1} D] (c : @category_theory.functor.{u u u u+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u u} C (@category_theory.category_struct.to_has_hom.{u u} C (@category_theory.category.to_category_struct.{u u} C _inst_1)) X Y → @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D _inst_2)) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u u u u+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J&#x27; (@category_theory.category_struct.to_has_hom.{u u} J&#x27; (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{u u+1} (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{u u u+1 u+1} C 𝒞 (@category_theory.functor.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.category.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.functor.const.{u u u u+1} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{u u+1} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{u u} C] {D : Type (u+1)} [𝒟 : category_theory.category.{u u+1} D] {F G : @category_theory.functor.{u u u u+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{u u u u+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{u u+1} D (@category_theory.category_struct.to_has_hom.{u u+1} D (@category_theory.category.to_category_struct.{u u+1} D 𝒟)) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{u u u u+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s :
  @category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
       (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       j)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    convert congr_fun (congr_arg (λ k : G.obj j ⟶ s.X, (k : G.obj j → s.X)) (s.ι.naturality f)) x;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : α → Type u} {f g : Π (x : α), β x}, @eq.{u+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{u+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} {a₁ a₂ : α} (f : α → β), @eq.{u+1} α a₁ a₂ → @eq.{u+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type (u+1)} [c : category_theory.has_hom.{u u+1} obj], obj → obj → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='J&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type u} [_inst_1 : category_theory.small_category.{u} J] {C : Type (u+1)} [𝒞 : category_theory.category.{u u+1} C] {F : @category_theory.functor.{u u u u+1} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{u u+1} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u u} J&#x27; (@category_theory.category_struct.to_has_hom.{u u} J&#x27; (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2)) j j&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;) (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s :
  @category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
       (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       j)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    { dsimp, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s :
  @category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
       (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       j)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j)
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s :
  @category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
       (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       j)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          j&#x27;))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.category_struct.comp.{u u+1} C&#x27;
          (@category_theory.category.to_category_struct.{u u+1} C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             j&#x27;)
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j&#x27;))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J&#x27; : Type u,
_inst_2 : category_theory.small_category.{u} J&#x27;,
C&#x27; : Type (u+1),
𝒞&#x27; : category_theory.concrete_category.{u} C&#x27;,
G : @category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;),
s :
  @category_theory.limits.cocone.{u u+1} J&#x27; _inst_2 C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;) G,
j j&#x27; : J&#x27;,
f :
  @category_theory.has_hom.hom.{u u} J&#x27;
    (@category_theory.category_struct.to_has_hom.{u u} J&#x27;
       (@category_theory.category.to_category_struct.{u u} J&#x27; _inst_2))
    j
    j&#x27;,
x :
  @coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
    (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
       (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
       G
       j)
⊢ @eq.{u+1}
    (@coe_sort.{u+2 u+2} C&#x27; (@category_theory.concrete_category.has_coe_to_sort.{u} C&#x27; 𝒞&#x27;)
       (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          s))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
          (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
          G
          (@category_theory.functor.obj.{u u u+1 u+1} C&#x27; (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
             (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s))
          (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          j&#x27;)
       (@coe_fn.{u+1 u+1}
          (@category_theory.has_hom.hom.{u u+1} C&#x27;
             (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
                (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j)
             (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                j&#x27;))
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          x))
    (@coe_fn.{u+1 u+1}
       (@category_theory.has_hom.hom.{u u+1} C&#x27;
          (@category_theory.category_struct.to_has_hom.{u u+1} C&#x27;
             (@category_theory.category.to_category_struct.{u u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.concrete_category.has_coe_to_fun.{u} C&#x27; 𝒞&#x27;
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s))
       (@category_theory.category_struct.comp.{u u+1} C&#x27;
          (@category_theory.category.to_category_struct.{u u+1} C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j)
          (@category_theory.functor.obj.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j&#x27;)
          (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             s)
          (@category_theory.functor.map.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             j
             j&#x27;
             f)
          (@category_theory.nat_trans.app.{u u u u+1} J&#x27; _inst_2 C&#x27;
             (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
             G
             (@category_theory.functor.obj.{u u u+1 u+1} C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                (@category_theory.functor.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.category.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.functor.const.{u u u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;))
                (@category_theory.limits.cocone.X.{u u+1} J&#x27; _inst_2 C&#x27;
                   (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                   G
                   s))
             (@category_theory.limits.cocone.ι.{u u+1} J&#x27; _inst_2 C&#x27;
                (@category_theory.concrete_category.to_category.{u} C&#x27; 𝒞&#x27;)
                G
                s)
             j&#x27;))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  end cocone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  @[ext] structure cone_morphism (A B : cone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  (hom : A.X ⟶ B.X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  (w&#x27;  : ∀ j : J, hom ≫ B.π.app j = A.π.app j . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  restate_axiom cone_morphism.w&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  attribute [simp] cone_morphism.w</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.cone_morphism.w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F} (c : @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F A B c) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F B) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F A) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  @[simps] instance cone.category : category.{v} (cone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  { hom  := λ A B, cone_morphism A B,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    comp := λ X Y Z f g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B)) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    { hom := f.hom ≫ g.hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B)) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220      w&#x27; := by intro j; rw [assoc, g.w, f.w] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u) [c : category_theory.category.{v u} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W X) (g : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y) (h : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) Y Z), @eq.{v+1} (@category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W Z) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W Y Z (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Z f (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F Y Z g) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Z) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Y) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Y) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
X Y Z : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    Y
    Z
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
            (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f)
            (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F Y Z g))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Z)
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
X Y Z : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    Y
    Z,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
          (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f)
          (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F Y Z g))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Z)
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
X Y Z : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    Y
    Z,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F Y Z g)
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z))
             F
             (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Z)
             j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
X Y Z : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    Y
    Z,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Y)
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
X Y Z : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    X
    Y,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    Y
    Z
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z)
            (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f)
            (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F Y Z g))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Z))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Z)
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    id   := λ B, { hom := 𝟙 B.X } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] (X : obj), @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  namespace cones</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  /-- To give an isomorphism between cones, it suffices to give an</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225    isomorphism between their vertices which commutes with the cone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    maps. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  @[ext, simps] def ext {c c&#x27; : cone F}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    (φ : c.X ≅ c&#x27;.X) (w : ∀ j, c.π.app j = φ.hom ≫ c&#x27;.π.app j) : c ≅ c&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  { hom := { hom := φ.hom },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    inv := { hom := φ.inv, w&#x27; := λ j, φ.inv_comp_eq.mpr (w j) } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv_comp_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y Z : C} (α : @category_theory.iso.{v u} C 𝒞 X Y) {f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Z} {g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z}, iff (@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) Y X Z (@category_theory.iso.inv.{v u} C 𝒞 X Y α) f) g) (@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Z) f (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X Y Z (@category_theory.iso.hom.{v u} C 𝒞 X Y α) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c&#x27;) j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  @[simps] def postcompose {G : J ⥤ C} (α : F ⟶ G) : cone F ⥤ cone G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u v)) [_inst_2 : category_theory.category.{v (max u v)} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  { obj := λ c, { X := c.X, π := c.π ≫ α },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    map := λ c₁ c₂ f, { hom := f.hom, w&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) c₁ c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) c₁ c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235    by intro; erw ← category.assoc; simp [-category.assoc] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u) [c : category_theory.category.{v u} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W X) (g : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y) (h : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) Y Z), @eq.{v+1} (@category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W Z) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W Y Z (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Z f (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
c₁ c₂ : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
    c₁
    c₂
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 G
            (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁)
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁))
                  F
                  G
                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₁)
                  α)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 G
            (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁)
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁))
                  F
                  G
                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₁)
                  α)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 G
            (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂)
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂))
                  F
                  G
                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₂)
                  α)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
         (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F c₁ c₂ f)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 G
                  (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂)
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂))
                        F
                        G
                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₂)
                        α))))
            G
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂)
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₂))
                     F
                     G
                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₂)
                     α)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁)
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁))
                     F
                     G
                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₁)
                     α))))
         G
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 G
            (@category_theory.limits.cone.mk.{v u} J _inst_1 C 𝒞 G
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁)
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c₁))
                  F
                  G
                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c₁)
                  α)))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  def postcompose_comp {G H : J ⥤ C} (α : F ⟶ G) (β : G ⟶ H) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238    postcompose (α ≫ β) ≅ postcompose α ⋙ postcompose β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cones.postcompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cones.postcompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cones.postcompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{(max u v) (max u v)} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {E : Type (max u v)} [ℰ : category_theory.category.{v (max u v)} E], @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟 → @category_theory.functor.{v v (max u v) (max u v)} D 𝒟 E ℰ → @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  by { fapply nat_iso.of_components, { intro s, fapply ext, refl, obviously }, obviously }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cones.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 227, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {F G : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C 𝒞)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max u v)} D (@category_theory.category_struct.to_has_hom.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟)) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {c c&#x27; : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F} (φ : @category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)), (∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c&#x27;) j))) → @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='To give an isomorphism between cones, it suffices to give an
 isomorphism between their vertices which commutes with the cone
 maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F
          G
          H
          α
          β))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ Π (X : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
            (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F
               G
               H
               α
               β))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
         X)

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ ∀ {X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
               Y)
            (?m_1 Y)))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            Y)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               X)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
               X)
            (?m_1 X))
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ Π (X : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
            (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F
               G
               H
               α
               β))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
         X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
          (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.category.to_category_struct.{v (max v u)}
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             F
             G
             H
             α
             β))
       s)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
          (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v u} C 𝒞
    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
             (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.category.to_category_struct.{v (max v u)}
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                F
                G
                H
                α
                β))
          s))
    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
             (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
             (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
             (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
             (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
             (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
             (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
          s))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s)))
         H
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               s))
         j)
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
               s))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                  s))
            ?m_1)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                     s)))
            H
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                  s))
            j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s)))
         H
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               s))
         j)
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
               s))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                  s))
            (@category_theory.iso.refl.{v u} C 𝒞
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s))))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                     s)))
            H
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                  s))
            j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ ∀ {X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
               Y)
            (@category_theory.limits.cones.ext.{v u} J _inst_1 C 𝒞 H
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  Y)
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                  Y)
               (@category_theory.iso.refl.{v u} C 𝒞
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                           (@category_theory.category_struct.comp.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.category.to_category_struct.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                              F
                              G
                              H
                              α
                              β))
                        Y)))
               (λ (j : J),
                  @id.{0}
                    (∀ {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (α :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         F
                         G)
                     (β :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         G
                         H) (s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.{v+1}
                         (@category_theory.has_hom.hom.{v u} C
                            (@category_theory.category_struct.to_has_hom.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s)))
                               j)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                        (@category_theory.category_struct.comp.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F
                                           G
                                           H
                                           α
                                           β))
                                     s)))
                            H
                            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                     (@category_theory.category_struct.comp.{v (max v u)}
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.category.to_category_struct.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                        F
                                        G
                                        H
                                        α
                                        β))
                                  s))
                            j)
                         (@category_theory.category_struct.comp.{v u} C
                            (@category_theory.category.to_category_struct.{v u} C 𝒞)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s)))
                               j)
                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                                  s))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                            (@category_theory.iso.hom.{v u} C 𝒞
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                        (@category_theory.category_struct.comp.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F
                                           G
                                           H
                                           α
                                           β))
                                     s))
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                                     s))
                               (@category_theory.iso.refl.{v u} C 𝒞
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s))))
                            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                           (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                           (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                           (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                                           (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                                           (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                           (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                           (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                                           (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                                        s)))
                               H
                               (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 H
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))
                                     s))
                               j)))
                    (λ {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (α :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         F
                         G)
                     (β :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         G
                         H) (s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.mpr.{0}
                         (@eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞))
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                               (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                  F
                                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                  j)
                               (@category_theory.category_struct.comp.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j)))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                               (@category_theory.category_struct.id.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                               (@category_theory.category_struct.comp.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j))))
                         true
                         (@id.{0}
                            (@eq.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j)))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.category_struct.comp.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                              F
                                              (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                              j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j))))
                               true)
                            (@eq.trans.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j)))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                     …
                                     …))
                               …
                               true
                               …
                               …))
                         trivial)
                    F
                    G
                    H
                    α
                    β
                    Y
                    j))))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  def postcompose_id : postcompose (𝟙 F) ≅ 𝟭 (cone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='category_theory.limits.cones.postcompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] (X : obj), @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{(max u v) (max u v)} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [𝒞 : category_theory.category.{v (max u v)} C], @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  by { fapply nat_iso.of_components, { intro s, fapply ext, refl, obviously }, obviously }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cones.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 227, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {F G : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C 𝒞)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max u v)} D (@category_theory.category_struct.to_has_hom.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟)) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {c c&#x27; : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F} (φ : @category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)), (∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c&#x27;) j))) → @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='To give an isomorphism between cones, it suffices to give an
 isomorphism between their vertices which commutes with the cone
 maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ Π (X : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
            (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
         X)

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ ∀ {X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
               Y)
            (?m_1 Y)))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               X)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
               X)
            (?m_1 X))
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ Π (X : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
            (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
         X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
          (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.category.to_category_struct.{v (max v u)}
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             F))
       s)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v u} C 𝒞
    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
             (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.category.to_category_struct.{v (max v u)}
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                F))
          s))
    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
          s))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s)))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               s))
         j)
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            ?m_1)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                     s)))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s)))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               s))
         j)
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            (@category_theory.iso.refl.{v u} C 𝒞
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s))))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                     s)))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ ∀ {X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
               Y)
            (@category_theory.limits.cones.ext.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  Y)
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                  Y)
               (@category_theory.iso.refl.{v u} C 𝒞
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                           (@category_theory.category_struct.id.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.category.to_category_struct.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                              F))
                        Y)))
               (λ (j : J),
                  @id.{0}
                    (∀ {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.{v+1}
                         (@category_theory.has_hom.hom.{v u} C
                            (@category_theory.category_struct.to_has_hom.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s)))
                               j)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                        (@category_theory.category_struct.id.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F))
                                     s)))
                            F
                            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                     (@category_theory.category_struct.id.{v (max v u)}
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.category.to_category_struct.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                        F))
                                  s))
                            j)
                         (@category_theory.category_struct.comp.{v u} C
                            (@category_theory.category.to_category_struct.{v u} C 𝒞)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s)))
                               j)
                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.id.{v (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                                  s))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                            (@category_theory.iso.hom.{v u} C 𝒞
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                        (@category_theory.category_struct.id.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F))
                                     s))
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.id.{v (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                                     s))
                               (@category_theory.iso.refl.{v u} C 𝒞
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s))))
                            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.functor.id.{v (max u v)}
                                           (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                           (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                                        s)))
                               F
                               (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.id.{v (max u v)}
                                        (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
                                     s))
                               j)))
                    (λ {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (s : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.mpr.{0}
                         (@eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞))
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                  F
                                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                  j)
                               (@category_theory.category_struct.id.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.category_struct.id.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                               (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                  (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                  F
                                  (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                  j)))
                         true
                         (@id.{0}
                            (@eq.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)))
                               true)
                            (@eq.trans.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)))
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     F
                                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                     j)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     F
                                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                     j))
                               true
                               ((λ
                                 (a a_1 :
                                   @category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                 (e_1 :
                                   @eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                     a
                                     a_1)
                                 (a_2 a_3 :
                                   @category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                 (e_2 :
                                   @eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                     a_2
                                     a_3),
                                   @congr.{v+1 1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                     Prop
                                     (@eq.{v+1}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        a)
                                     (@eq.{v+1}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        a_1)
                                     a_2
                                     a_3
                                     (@congr_arg.{v+1 (max (v+1) 1)}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) →
                                         Prop)
                                        a
                                        a_1
                                        (@eq.{v+1}
                                           (@category_theory.has_hom.hom.{v u} C
                                              (@category_theory.category_struct.to_has_hom.{v u} C
                                                 (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                              (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)))
                                        e_1)
                                     e_2)
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     F
                                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                     j)
                                  (@category_theory.category.comp_id.{v u} C 𝒞
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                        F
                                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                        j))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s))
                                     F
                                     (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F s)
                                     j)
                                  (@category_theory.category.id_comp.{v u} C 𝒞
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                           …)
                                        F
                                        …
                                        j)))
                               …))
                         trivial)
                    F
                    Y
                    j))))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  def postcompose_equivalence {G : J ⥤ C} (α : F ≅ G) : cone F ≌ cone G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u v)) [_inst_2 : category_theory.category.{v (max u v)} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law `Fη ≫ εF = 1`, or in other
 words the composite `F ⟶ FGF ⟶ F` is the identity.

 The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like `F ⟶ F1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.equivalence.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    refine equivalence.mk (postcompose α.hom) (postcompose α.inv) _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.equivalence.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cones.postcompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 146, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 232, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] (F : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (G : @category_theory.functor.{v v (max u v) (max u v)} D 𝒟 C 𝒞), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 C 𝒞) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 C 𝒞) (@category_theory.functor.id.{v (max u v)} C 𝒞) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} C 𝒞 D 𝒟 C 𝒞 F G) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} D 𝒟 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} D 𝒟 D 𝒟) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v (max u v)} D 𝒟) → @category_theory.equivalence.{v v (max u v) (max u v)} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C}, @category_theory.iso.{v (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.equivalence.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
    (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    { symmetry,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248      refine (postcompose_comp _ _).symm.trans _, rw [iso.hom_inv_id], exact postcompose_id },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cones.postcompose_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.cones.postcompose_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 237, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 241, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (α : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G) (β : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F G H α β)) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C} (c : @category_theory.iso.{v (max v u)} C _inst_1 X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X X) (@category_theory.category_struct.comp.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) X Y X (@category_theory.iso.hom.{v (max v u)} C _inst_1 X Y c) (@category_theory.iso.inv.{v (max v u)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F)) (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F
          G
          F
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249    { refine (postcompose_comp _ _).symm.trans _, rw [iso.inv_hom_id], exact postcompose_id }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cones.postcompose_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.cones.postcompose_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 237, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 241, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (α : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G) (β : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H)) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F H (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F G H α β)) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G α) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G H β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C} (c : @category_theory.iso.{v (max v u)} C _inst_1 X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) Y X Y (@category_theory.iso.inv.{v (max v u)} C _inst_1 X Y c) (@category_theory.iso.hom.{v (max v u)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F F (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F)) (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α))
       (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G G
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          G
          F
          G
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             F
             G
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    F
    G
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.limits.cones.postcompose.{v u} J _inst_1 C 𝒞 G G
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          G))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  @[simps] def forget : cone F ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  { obj := λ t, t.X, map := λ s t f, f.hom }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  variables {D : Type u&#x27;} [𝒟 : category.{v} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  include 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  @[simps] def functoriality (G : C ⥤ D) : cone F ⥤ cone (F ⋙ G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type u&#x27;) [_inst_2 : category_theory.category.{v u&#x27;} D], Type (max v u u&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u&#x27; v)) [_inst_2 : category_theory.category.{v (max u&#x27; v)} D], Type (max v (max u v) u&#x27; v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  { obj := λ A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    { X := G.obj A.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262      π := { app := λ j, G.map (A.π.app j), naturality&#x27; := by intros; erw ←G.map_comp; tidy } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)) (g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)), @eq.{v+1} (@category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) f g)) (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) f) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
A : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ ⦃X Y : J⦄
  (f :
    @category_theory.has_hom.hom.{v v} J
      (@category_theory.category_struct.to_has_hom.{v v} J
         (@category_theory.category.to_category_struct.{v v} J _inst_1))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)))
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            Y))
      (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)))
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)))
            Y)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            Y)
         (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)))
            X
            Y
            f)
         (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)
            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A))
               F
               (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F A)
               Y)))
      (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)))
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            Y)
         (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A)
            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A))
               F
               (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F A)
               X))
         (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    map := λ X Y f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    { hom := G.map f.hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265      w&#x27;  := by intros; rw [←functor.map_comp, f.w] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) Y Z), @eq.{v+1} (@category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cone_morphism.hom.{v u} J _inst_1 C 𝒞 F X Y f) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F Y)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F Y) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
    X
    Y
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.limits.cone.X.{v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            (@category_theory.limits.cone.mk.{v u&#x27;} J _inst_1 D 𝒟
               (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
               (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                  (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                     (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                  (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                  (λ (j : J),
                     @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                          F
                          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                          j))
                  (λ (X_1 Y : J)
                   (f :
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   X_1))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X_1
                                Y
                                f)))
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   Y)))
                          (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                             (@category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   X_1)
                                (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         X_1))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X_1
                                      Y
                                      f)))
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         Y)))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.category_struct.comp.{v u} C
                                      (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         X_1)
                                      (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))))
                          (@eq.rec.{0 v+1}
                             (@category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)))
                             (@category_theory.category_struct.comp.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                      F
                                      (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                      X_1))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v u&#x27;} D
                                  (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                     (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))),
                                @eq.{1} Prop
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                              F
                                              (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                              Y)))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                              F
                                              (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                              X_1))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X_1
                                           Y
                                           f)))
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 …)
                                              F
                                              …
                                              Y)))
                                     _a))
                             …
                             …
                             …))
                       …))))
         …)
      …
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
    X
    Y,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u&#x27;} D
       (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
          (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
       (@category_theory.limits.cone.X.{v u&#x27;} J _inst_1 D 𝒟
          (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
          (@category_theory.limits.cone.mk.{v u&#x27;} J _inst_1 D 𝒟
             (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
             (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
             (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                (λ (j : J),
                   @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                        F
                        (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                        j))
                (λ (X_1 Y : J)
                 (f :
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     X_1
                     Y),
                   @eq.mpr.{0}
                     (@eq.{v+1}
                        (@category_theory.has_hom.hom.{v u&#x27;} D
                           (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              Y)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y)
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1
                              Y
                              f)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                 F
                                 (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                 Y)))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                 F
                                 (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                 X_1))
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X_1
                              Y
                              f)))
                     (@eq.{v+1}
                        (@category_theory.has_hom.hom.{v u&#x27;} D
                           (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              Y)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y)
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                              X_1
                              Y
                              f)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                 F
                                 (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                 Y)))
                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                           (@category_theory.category_struct.comp.{v u} C
                              (@category_theory.category.to_category_struct.{v u} C 𝒞)
                              (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                 F
                                 (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                 X_1)
                              (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f))))
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{v+1}
                              (@category_theory.has_hom.hom.{v u&#x27;} D
                                 (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                    (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    Y)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y)
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1
                                    Y
                                    f)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                       F
                                       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                       Y)))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                       F
                                       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                       X_1))
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X_1
                                    Y
                                    f)))
                           (@eq.{v+1}
                              (@category_theory.has_hom.hom.{v u&#x27;} D
                                 (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                    (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    Y)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y)
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                    X_1
                                    Y
                                    f)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                       F
                                       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                       Y)))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                 (@category_theory.category_struct.comp.{v u} C
                                    (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                    (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                       F
                                       (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                       X_1)
                                    (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))))
                        (@eq.rec.{0 v+1}
                           (@category_theory.has_hom.hom.{v u&#x27;} D
                              (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)))
                           (@category_theory.category_struct.comp.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                 (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                    (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                    F
                                    (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                    X_1))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                 (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))
                           (λ
                            (_a :
                              @category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))),
                              @eq.{1} Prop
                                (@eq.{v+1}
                                   (@category_theory.has_hom.hom.{v u&#x27;} D
                                      (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                         (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y))
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         Y)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y)
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1
                                         Y
                                         f)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                            F
                                            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                            Y)))
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                            F
                                            (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                            X_1))
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X_1
                                         Y
                                         f)))
                                (@eq.{v+1}
                                   (@category_theory.has_hom.hom.{v u&#x27;} D
                                      (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                         (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y))
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         Y)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y)
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                         X_1
                                         Y
                                         f)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               …)
                                            F
                                            …
                                            Y)))
                                   _a))
                           …
                           …
                           …))
                     …))))
       …)
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
X Y : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F)))
    X
    Y
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.limits.cone.X.{v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            (@category_theory.limits.cone.mk.{v u&#x27;} J _inst_1 D 𝒟
               (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
               (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                  (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                     (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                        (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                  (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                  (λ (j : J),
                     @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                       (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                          F
                          (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                          j))
                  (λ (X_1 Y : J)
                   (f :
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       X_1
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   X_1))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X_1
                                Y
                                f)))
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                X_1
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   Y)))
                          (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                             (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                             (@category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                   F
                                   (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                   X_1)
                                (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f))))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         X_1))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X_1
                                      Y
                                      f)))
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                      X_1
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         Y)))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.category_struct.comp.{v u} C
                                      (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                      (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                         F
                                         (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                         X_1)
                                      (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))))
                          (@eq.rec.{0 v+1}
                             (@category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)))
                             (@category_theory.category_struct.comp.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                      F
                                      (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                      X_1))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X_1 Y f)))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v u&#x27;} D
                                  (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                     (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))),
                                @eq.{1} Prop
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                              F
                                              (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                              Y)))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X_1)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X))
                                              F
                                              (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F X)
                                              X_1))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X_1
                                           Y
                                           f)))
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)))
                                           X_1
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 …)
                                              F
                                              …
                                              Y)))
                                     _a))
                             …
                             …
                             …))
                       …))))
         …)
      …
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  end cones</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  @[ext] structure cocone_morphism (A B : cocone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  (hom : A.X ⟶ B.X)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  (w&#x27;  : ∀ j : J, A.ι.app j ≫ hom = B.ι.app j . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  restate_axiom cocone_morphism.w&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  attribute [simp] cocone_morphism.w</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.cocone_morphism.w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F} (c : @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F A) j) (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F A B c)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F B) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  @[simps] instance cocone.category : category.{v} (cocone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  { hom  := λ A B, cocone_morphism A B,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278    comp := λ _ _ _ f g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279    { hom := f.hom ≫ g.hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B)) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280      w&#x27; := by intro j; rw [←assoc, f.w, g.w] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u) [c : category_theory.category.{v u} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W X) (g : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) X Y) (h : @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) Y Z), @eq.{v+1} (@category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c)) W Z) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W Y Z (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) W X Z f (@category_theory.category_struct.comp.{v u} obj (@category_theory.category.to_category_struct.{v u} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x_1) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x_1)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x_1) j) (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x_1 _x f)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x_1) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x_1)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x_1) j) (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x_1 _x g)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
_x _x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
            j)
         (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x f)
            (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x g)))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
_x _x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
          j)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
          (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x f)
          (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x g)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
_x _x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
          (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
             j)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
             (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
             j)
          (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x f))
       (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x g))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
_x _x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
          j)
       (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x g))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
_x _x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.has_hom.mk.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (λ (A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
          @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B))
    _x
    _x
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
            j)
         (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
            (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x f)
            (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F _x _x g)))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    id   := λ B, { hom := 𝟙 B.X } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] (X : obj), @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  namespace cocones</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  /-- To give an isomorphism between cocones, it suffices to give an</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285    isomorphism between their vertices which commutes with the cocone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    maps. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  @[ext, simps] def ext {c c&#x27; : cocone F}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    (φ : c.X ≅ c&#x27;.X) (w : ∀ j, c.ι.app j ≫ φ.hom = c&#x27;.ι.app j) : c ≅ c&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Y → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) Y Z → @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  { hom := { hom := φ.hom },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290    inv := { hom := φ.inv, w&#x27; := λ j, φ.comp_inv_eq.mpr (w j).symm } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.comp_inv_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {X Y : C}, @category_theory.iso.{v u} C _inst_1 X Y → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y Z : C} (α : @category_theory.iso.{v u} C 𝒞 X Y) {f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Z Y} {g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Z X}, iff (@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Z X) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) Z Y X f (@category_theory.iso.inv.{v u} C 𝒞 X Y α)) g) (@eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Z Y) f (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) Z X Y g (@category_theory.iso.hom.{v u} C 𝒞 X Y α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c&#x27;) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  @[simps] def precompose {G : J ⥤ C} (α : G ⟶ F) : cocone F ⥤ cocone G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u v)) [_inst_2 : category_theory.category.{v (max u v)} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  { obj := λ c, { X := c.X, ι := α ≫ c.ι },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294    map := λ c₁ c₂ f, { hom := f.hom } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) c₁ c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) c₁ c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  def precompose_comp {G H : J ⥤ C} (α : F ⟶ G) (β : G ⟶ H) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297    precompose (α ≫ β) ≅ precompose β ⋙ precompose α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocones.precompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocones.precompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocones.precompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{(max u v) (max u v)} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {E : Type (max u v)} [ℰ : category_theory.category.{v (max u v)} E], @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟 → @category_theory.functor.{v v (max u v) (max u v)} D 𝒟 E ℰ → @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  by { fapply nat_iso.of_components, { intro s, fapply ext, refl, obviously }, obviously }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cocones.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 287, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {F G : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C 𝒞)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max u v)} D (@category_theory.category_struct.to_has_hom.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟)) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {c c&#x27; : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F} (φ : @category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)), (∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c&#x27;) j)) → @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='To give an isomorphism between cocones, it suffices to give an
 isomorphism between their vertices which commutes with the cocone
 maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F
          G
          H
          α
          β))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ Π (X : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
            (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F
               G
               H
               α
               β))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
         X)

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ ∀ {X Y : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.category_struct.to_has_hom.{v (max u v)}
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               Y)
            (?m_1 Y)))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            Y)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               X)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               X)
            (?m_1 X))
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ Π (X : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
            (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F
               G
               H
               α
               β))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
         X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H
⊢ @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
          (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.category.to_category_struct.{v (max v u)}
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             F
             G
             H
             α
             β))
       s)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
          (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H
⊢ @category_theory.iso.{v u} C 𝒞
    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
             (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.category.to_category_struct.{v (max v u)}
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                F
                G
                H
                α
                β))
          s))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
             (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
             (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
             (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
             (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
             (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
             (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
          s))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                  s))
            ?m_1))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                  s)))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  s))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                  s))
            (@category_theory.iso.refl.{v u} C 𝒞
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                        (@category_theory.category_struct.comp.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F
                           G
                           H
                           α
                           β))
                     s)))))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                  s)))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    F
    G,
β :
  @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
       (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
    G
    H
⊢ ∀ {X Y : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
      (@category_theory.category_struct.to_has_hom.{v (max u v)}
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
               (@category_theory.category_struct.comp.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F
                  G
                  H
                  α
                  β))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                  (@category_theory.category_struct.comp.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F
                     G
                     H
                     α
                     β))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
               Y)
            (@category_theory.limits.cocones.ext.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                     (@category_theory.category_struct.comp.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F
                        G
                        H
                        α
                        β))
                  Y)
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                  Y)
               (@category_theory.iso.refl.{v u} C 𝒞
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                           (@category_theory.category_struct.comp.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.category.to_category_struct.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                              F
                              G
                              H
                              α
                              β))
                        Y)))
               (λ (j : J),
                  @id.{0}
                    (∀ {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (α :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         F
                         G)
                     (β :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         G
                         H) (s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (j : J),
                       @eq.{v+1}
                         (@category_theory.has_hom.hom.{v u} C
                            (@category_theory.category_struct.to_has_hom.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                                  s)))
                         (@category_theory.category_struct.comp.{v u} C
                            (@category_theory.category.to_category_struct.{v u} C 𝒞)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s)))
                               j)
                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                                  s))
                            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s)))
                               (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                                        (@category_theory.category_struct.comp.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F
                                           G
                                           H
                                           α
                                           β))
                                     s))
                               j)
                            (@category_theory.iso.hom.{v u} C 𝒞
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                                        (@category_theory.category_struct.comp.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F
                                           G
                                           H
                                           α
                                           β))
                                     s))
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                                     s))
                               (@category_theory.iso.refl.{v u} C 𝒞
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F
                                           (@category_theory.category_struct.comp.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F
                                              G
                                              H
                                              α
                                              β))
                                        s)))))
                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                                     s)))
                            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))
                                  s))
                            j))
                    (λ {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (α :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         F
                         G)
                     (β :
                       @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                         (@category_theory.category_struct.to_has_hom.{v (max v u)}
                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                            (@category_theory.category.to_category_struct.{v (max v u)}
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)))
                         G
                         H) (s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (j : J),
                       @eq.mpr.{0}
                         (@eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞))
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                               (@category_theory.category_struct.comp.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 H s)
                                     j))
                               (@category_theory.category_struct.id.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                               (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                               (@category_theory.category_struct.comp.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 H
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 H s)
                                     j))))
                         true
                         (@id.{0}
                            (@eq.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                        (@category_theory.category_struct.comp.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 H
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 H s)
                                           j))
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 H
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 H s)
                                           j))))
                               true)
                            (@eq.trans.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s)
                                        (@category_theory.category_struct.comp.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 G j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 H j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F G α j)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 G H β j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 H
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 H s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 H s)
                                           j))
                                     …)
                                  …)
                               …
                               true
                               …
                               …))
                         trivial)
                    F
                    G
                    H
                    α
                    β
                    Y
                    j))))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  def precompose_id : precompose (𝟙 F) ≅ 𝟭 (cocone F) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cocones.precompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] (X : obj), @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{(max u v) (max u v)} C], C → C → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [𝒞 : category_theory.category.{v (max u v)} C], @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  by { fapply nat_iso.of_components, { intro s, fapply ext, refl, obviously }, obviously }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cocones.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 287, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] {F G : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C 𝒞)) X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max u v)} D (@category_theory.category_struct.to_has_hom.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟)) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v (max u v)} D (@category_theory.category.to_category_struct.{v (max u v)} D 𝒟) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v (max u v)} D 𝒟 (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v v (max u v) (max u v)} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {c c&#x27; : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F} (φ : @category_theory.iso.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)), (∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c) j) (@category_theory.iso.hom.{v u} C 𝒞 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;) φ)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c&#x27;)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c&#x27;) j)) → @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to the `apply` tactic, but does not reorder goals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='To give an isomorphism between cocones, it suffices to give an
 isomorphism between their vertices which commutes with the cocone
 maps.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='fapply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ Π (X : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
            (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         X)

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ ∀ {X Y : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)}
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               Y)
            (?m_1 Y)))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               X)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               X)
            (?m_1 X))
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ Π (X : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F),
    @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
            (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.category.to_category_struct.{v (max v u)}
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
               F))
         X)
      (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
          (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.category.to_category_struct.{v (max v u)}
                (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
             F))
       s)
    (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ @category_theory.iso.{v u} C 𝒞
    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
             (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                (@category_theory.category.to_category_struct.{v (max v u)}
                   (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                   (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                F))
          s))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
       (@category_theory.functor.obj.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
          s))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            ?m_1))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                  s)))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            j)
         (@category_theory.iso.hom.{v u} C 𝒞
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  s))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                  s))
            (@category_theory.iso.refl.{v u} C 𝒞
               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                        (@category_theory.category_struct.id.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.category.to_category_struct.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                           F))
                     s)))))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                  s)))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞
⊢ ∀ {X Y : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}
  (f :
    @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
      (@category_theory.category_struct.to_has_hom.{v (max u v)}
         (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category_struct.to_has_hom.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.category.to_category_struct.{v (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            Y))
      (@category_theory.category_struct.comp.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
         (@category_theory.category.to_category_struct.{v (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            Y)
         (@category_theory.functor.obj.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
            Y)
         (@category_theory.functor.map.{v v (max u v) (max u v)}
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
               (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.category.to_category_struct.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                  F))
            X
            Y
            f)
         (@category_theory.iso.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                  (@category_theory.category_struct.id.{v (max v u)}
                     (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                     (@category_theory.category.to_category_struct.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                     F))
               Y)
            (@category_theory.functor.obj.{v v (max u v) (max u v)}
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
               (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
               Y)
            (@category_theory.limits.cocones.ext.{v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                     (@category_theory.category_struct.id.{v (max v u)}
                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                        (@category_theory.category.to_category_struct.{v (max v u)}
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                        F))
                  Y)
               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                  (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                  Y)
               (@category_theory.iso.refl.{v u} C 𝒞
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                           (@category_theory.category_struct.id.{v (max v u)}
                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                              (@category_theory.category.to_category_struct.{v (max v u)}
                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                              F))
                        Y)))
               (λ (j : J),
                  @id.{0}
                    (∀ {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.{v+1}
                         (@category_theory.has_hom.hom.{v u} C
                            (@category_theory.category_struct.to_has_hom.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞))
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.id.{v (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                                  s)))
                         (@category_theory.category_struct.comp.{v u} C
                            (@category_theory.category.to_category_struct.{v u} C 𝒞)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s)))
                               j)
                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.id.{v (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                                  s))
                            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s)))
                               (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                                        (@category_theory.category_struct.id.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F))
                                     s))
                               j)
                            (@category_theory.iso.hom.{v u} C 𝒞
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                                        (@category_theory.category_struct.id.{v (max v u)}
                                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                           (@category_theory.category.to_category_struct.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                           F))
                                     s))
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.id.{v (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                                     s))
                               (@category_theory.iso.refl.{v u} C 𝒞
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
                                           (@category_theory.category_struct.id.{v (max v u)}
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.category.to_category_struct.{v (max v u)}
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
                                              F))
                                        s)))))
                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F
                                  (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.functor.id.{v (max u v)}
                                        (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                        (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                                     s)))
                            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v (max u v) (max u v)}
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
                                  (@category_theory.functor.id.{v (max u v)}
                                     (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
                                     (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
                                  s))
                            j))
                    (λ {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}
                     (s : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (j : J),
                       @eq.mpr.{0}
                         (@eq.{v+1}
                            (@category_theory.has_hom.hom.{v u} C
                               (@category_theory.category_struct.to_has_hom.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞))
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                            (@category_theory.category_struct.comp.{v u} C
                               (@category_theory.category.to_category_struct.{v u} C 𝒞)
                               (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                               (@category_theory.category_struct.comp.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                  (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                  (@category_theory.category_struct.id.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j))
                               (@category_theory.category_struct.id.{v u} C
                                  (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                               (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                               j))
                         true
                         (@id.{0}
                            (@eq.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.category_struct.id.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                           j))
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j))
                               true)
                            (@eq.trans.{1} Prop
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.category_struct.id.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                           j))
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j))
                               (@eq.{v+1}
                                  (@category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j)
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j))
                               true
                               ((λ
                                 (a a_1 :
                                   @category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                 (e_1 :
                                   @eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     a
                                     a_1)
                                 (a_2 a_3 :
                                   @category_theory.has_hom.hom.{v u} C
                                     (@category_theory.category_struct.to_has_hom.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                 (e_2 :
                                   @eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     a_2
                                     a_3),
                                   @congr.{v+1 1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     Prop
                                     (@eq.{v+1}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                        a)
                                     (@eq.{v+1}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                        a_1)
                                     a_2
                                     a_3
                                     (@congr_arg.{v+1 (max (v+1) 1)}
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                        (@category_theory.has_hom.hom.{v u} C
                                           (@category_theory.category_struct.to_has_hom.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s) →
                                         Prop)
                                        a
                                        a_1
                                        (@eq.{v+1}
                                           (@category_theory.has_hom.hom.{v u} C
                                              (@category_theory.category_struct.to_has_hom.{v u} C
                                                 (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                                        e_1)
                                     e_2)
                                  (@category_theory.category_struct.comp.{v u} C
                                     (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.category_struct.id.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                           j))
                                     (@category_theory.category_struct.id.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                                  (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                     (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                        (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                     j)
                                  (@eq.trans.{v+1}
                                     (@category_theory.has_hom.hom.{v u} C
                                        (@category_theory.category_struct.to_has_hom.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞))
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.category_struct.comp.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                           (@category_theory.category_struct.id.{v u} C
                                              (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j))
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                              j))
                                        (@category_theory.category_struct.id.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)))
                                     (@category_theory.category_struct.comp.{v u} C
                                        (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                        (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s)
                                        (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                           (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                              (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F s))
                                           (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F s)
                                           j)
                                        (@category_theory.category_struct.id.{v u} C
                                           (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                           (… s)))
                                     …
                                     …
                                     …)
                                  …
                                  …
                                  …)
                               …))
                         trivial)
                    F
                    Y
                    j))))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  def precompose_equivalence {G : J ⥤ C} (α : G ≅ F) : cocone F ≌ cocone G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C], C → C → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u v)) [_inst_2 : category_theory.category.{v (max u v)} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law `Fη ≫ εF = 1`, or in other
 words the composite `F ⟶ FGF ⟶ F` is the identity.

 The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like `F ⟶ F1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.equivalence.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305    refine equivalence.mk (precompose α.hom) (precompose α.inv) _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.equivalence.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cocones.precompose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 146, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 292, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max u v)} [𝒞 : category_theory.category.{v (max u v)} C] {D : Type (max u v)} [𝒟 : category_theory.category.{v (max u v)} D] (F : @category_theory.functor.{v v (max u v) (max u v)} C 𝒞 D 𝒟) (G : @category_theory.functor.{v v (max u v) (max u v)} D 𝒟 C 𝒞), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} C 𝒞 C 𝒞) (@category_theory.functor.category.{v v (max u v) (max u v)} C 𝒞 C 𝒞) (@category_theory.functor.id.{v (max u v)} C 𝒞) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} C 𝒞 D 𝒟 C 𝒞 F G) → @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} D 𝒟 D 𝒟) (@category_theory.functor.category.{v v (max u v) (max u v)} D 𝒟 D 𝒟) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v (max u v)} D 𝒟) → @category_theory.equivalence.{v v (max u v) (max u v)} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C}, @category_theory.iso.{v (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G F → @category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) G F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.equivalence.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
    (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306    { symmetry, refine (precompose_comp _ _).symm.trans _, rw [iso.inv_hom_id], exact precompose_id },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.cocones.precompose_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.cocones.precompose_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1269, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 296, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 300, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (α : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G) (β : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F G H α β)) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C} (c : @category_theory.iso.{v (max v u)} C _inst_1 X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) Y X Y (@category_theory.iso.inv.{v (max v u)} C _inst_1 X Y c) (@category_theory.iso.hom.{v (max v u)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F)) (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='symmetry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))

J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F
          G
          F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          F))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    { refine (precompose_comp _ _).symm.trans _, rw [iso.hom_inv_id], exact precompose_id }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cocones.precompose_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.cocones.precompose_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 296, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 300, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F G H : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (α : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F G) (β : @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) G H), @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H F (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F G H α β)) (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 H) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 H G β) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C} (c : @category_theory.iso.{v (max v u)} C _inst_1 X Y), @eq.{v+1} (@category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X X) (@category_theory.category_struct.comp.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) X Y X (@category_theory.iso.hom.{v (max v u)} C _inst_1 X Y c) (@category_theory.iso.inv.{v (max v u)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.iso.{(max u v) (max u v)} (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.functor.category.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)) (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F F (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)) F)) (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.comp.{v v v (max u v) (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G F
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α))
       (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 F G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G G
       (@category_theory.category_struct.comp.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          G
          F
          G
          (@category_theory.iso.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)
          (@category_theory.iso.inv.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
             G
             F
             α)))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F G : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
α :
  @category_theory.iso.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
    G
    F
⊢ @category_theory.iso.{(max u v) (max u v)}
    (@category_theory.functor.{v v (max u v) (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.functor.category.{v v (max u v) (max u v)}
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))
    (@category_theory.limits.cocones.precompose.{v u} J _inst_1 C 𝒞 G G
       (@category_theory.category_struct.id.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
          (@category_theory.category.to_category_struct.{v (max v u)}
             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))
          G))
    (@category_theory.functor.id.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 G)
       (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  @[simps] def forget : cocone F ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  { obj := λ t, t.X, map := λ s t f, f.hom }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  variables {D : Type u&#x27;} [𝒟 : category.{v} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  include 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  @[simps] def functoriality (G : C ⥤ D) : cocone F ⥤ cocone (F ⋙ G) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type u&#x27;) [_inst_2 : category_theory.category.{v u&#x27;} D], Type (max v u u&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u v)) [_inst_1 : category_theory.category.{v (max u v)} C] (D : Type (max u&#x27; v)) [_inst_2 : category_theory.category.{v (max u&#x27; v)} D], Type (max v (max u v) u&#x27; v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  { obj := λ A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319    { X := G.obj A.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320      ι := { app := λ j, G.map (A.ι.app j), naturality&#x27; := by intros; erw ←G.map_comp; tidy } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)) (g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)), @eq.{v+1} (@category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A))) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) f g)) (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)) (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) f) (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
A : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F
⊢ ∀ ⦃X Y : J⦄
  (f :
    @category_theory.has_hom.hom.{v v} J
      (@category_theory.category_struct.to_has_hom.{v v} J
         (@category_theory.category.to_category_struct.{v v} J _inst_1))
      X
      Y),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)))
            Y))
      (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            Y)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)))
            Y)
         (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X
            Y
            f)
         (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)
            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A))
               (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F A)
               Y)))
      (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)))
            X)
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)))
            Y)
         (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
            (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)
            (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
               (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                  (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A))
               (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F A)
               X))
         (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
               (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)))
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321    map := λ _ _ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322    { hom := G.map f.hom,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone_morphism.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.category.to_category_struct.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F}, @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B → @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323      w&#x27;  := by intros; rw [←functor.map_comp, cocone_morphism.w] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.functor.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone_morphism.w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y Z : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y) (g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) Y Z), @eq.{v+1} (@category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Z)) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c X Z (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1) X Y Z f g)) (@category_theory.category_struct.comp.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Z) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c X Y f) (@category_theory.functor.map.{v v u u&#x27;} C _inst_1 D _inst_2 c Y Z g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {A B : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F} (c : @category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F A B) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F A)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F A) j) (@category_theory.limits.cocone_morphism.hom.{v u} J _inst_1 C 𝒞 F A B c)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F B)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F B) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
_x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
    _x
    _x
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            j)
         (@category_theory.limits.cocone.X.{v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            (@category_theory.limits.cocone.mk.{v u&#x27;} J _inst_1 D 𝒟
               (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
               (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                  (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                  (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                     (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                  (λ (j : J),
                     @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                          j))
                  (λ (X Y : J)
                   (f :
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       X
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   X))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X
                                Y
                                f)))
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y))
                          (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                             (@category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   X))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X
                                Y
                                f)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         X))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X
                                      Y
                                      f)))
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                   (@category_theory.category_struct.comp.{v u} C
                                      (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         X))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X
                                      Y
                                      f))))
                          (@eq.rec.{0 v+1}
                             (@category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                             (@category_theory.category_struct.comp.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                      (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                      Y)))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v u&#x27;} D
                                  (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                     (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))),
                                @eq.{1} Prop
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              Y)))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              X))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X
                                           Y
                                           f)))
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y))
                                     _a
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              X))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟 (… …) X Y f))))
                             …
                             …
                             …))
                       …)))))
      …
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
_x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
    _x
    _x,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u&#x27;} D
       (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
          (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
       (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
          (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
          j)
       (@category_theory.limits.cocone.X.{v u&#x27;} J _inst_1 D 𝒟
          (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
          (@category_theory.limits.cocone.mk.{v u&#x27;} J _inst_1 D 𝒟
             (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
             (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
             (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                (λ (j : J),
                   @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                     (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                        (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                           (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                        (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                        j))
                (λ (X Y : J)
                 (f :
                   @category_theory.has_hom.hom.{v v} J
                     (@category_theory.category_struct.to_has_hom.{v v} J
                        (@category_theory.category.to_category_struct.{v v} J _inst_1))
                     X
                     Y),
                   @eq.mpr.{0}
                     (@eq.{v+1}
                        (@category_theory.has_hom.hom.{v u&#x27;} D
                           (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              Y))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              Y)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              Y)
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X
                              Y
                              f)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                 (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                 Y)))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              Y)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                 (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                 X))
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              X
                              Y
                              f)))
                     (@eq.{v+1}
                        (@category_theory.has_hom.hom.{v u&#x27;} D
                           (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              Y))
                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                           (@category_theory.category_struct.comp.{v u} C
                              (@category_theory.category.to_category_struct.{v u} C 𝒞)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                              (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                 (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                 Y)))
                        (@category_theory.category_struct.comp.{v u&#x27;} D
                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              X)
                           (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              Y)
                           (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                              (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                              (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                              (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                    (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                 (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                 X))
                           (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                              (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                 (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                 (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                              X
                              Y
                              f)))
                     (@id.{0}
                        (@eq.{1} Prop
                           (@eq.{v+1}
                              (@category_theory.has_hom.hom.{v u&#x27;} D
                                 (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                    (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    Y))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    Y)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    Y)
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X
                                    Y
                                    f)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                       Y)))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    Y)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                       X))
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    X
                                    Y
                                    f)))
                           (@eq.{v+1}
                              (@category_theory.has_hom.hom.{v u&#x27;} D
                                 (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                    (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    Y))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                 (@category_theory.category_struct.comp.{v u} C
                                    (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                    (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                       Y)))
                              (@category_theory.category_struct.comp.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    X)
                                 (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    Y)
                                 (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                    (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                    (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                    (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                          (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                       (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                       X))
                                 (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                    (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                       (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                       (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                          (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                    X
                                    Y
                                    f))))
                        (@eq.rec.{0 v+1}
                           (@category_theory.has_hom.hom.{v u&#x27;} D
                              (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                 (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                           (@category_theory.category_struct.comp.{v u&#x27;} D
                              (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                 (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f))
                              (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                 (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                 (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                    (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                       (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                    (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                    Y)))
                           (λ
                            (_a :
                              @category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))),
                              @eq.{1} Prop
                                (@eq.{v+1}
                                   (@category_theory.has_hom.hom.{v u&#x27;} D
                                      (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                         (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         Y))
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         Y)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         Y)
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X
                                         Y
                                         f)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                            Y)))
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         Y)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                            X))
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         X
                                         Y
                                         f)))
                                (@eq.{v+1}
                                   (@category_theory.has_hom.hom.{v u&#x27;} D
                                      (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                         (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         Y))
                                   _a
                                   (@category_theory.category_struct.comp.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         X)
                                      (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                         (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                            (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                            (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                         Y)
                                      (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                         (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                         (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                               (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                               (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                            (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                            X))
                                      (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟 (… … … …) X Y
                                         f))))
                           …
                           …
                           …))
                     …)))))
    …
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞,
D : Type u&#x27;,
𝒟 : category_theory.category.{v u&#x27;} D,
G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟,
_x _x : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F,
f :
  @category_theory.has_hom.hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
    (@category_theory.category_struct.to_has_hom.{v (max u v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
       (@category_theory.category.to_category_struct.{v (max u v)}
          (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F)))
    _x
    _x
⊢ ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u&#x27;} D
         (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
            (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
         (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            j)
         (@category_theory.limits.cocone.X.{v u&#x27;} J _inst_1 D 𝒟
            (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
            (@category_theory.limits.cocone.mk.{v u&#x27;} J _inst_1 D 𝒟
               (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
               (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                  (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
               (@category_theory.nat_trans.mk.{v v v u&#x27;} J _inst_1 D 𝒟
                  (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                  (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                     (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                     (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                        (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                  (λ (j : J),
                     @category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                       (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)
                       (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                       (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                             (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                          (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                          j))
                  (λ (X Y : J)
                   (f :
                     @category_theory.has_hom.hom.{v v} J
                       (@category_theory.category_struct.to_has_hom.{v v} J
                          (@category_theory.category.to_category_struct.{v v} J _inst_1))
                       X
                       Y),
                     @eq.mpr.{0}
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                Y)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X
                                Y
                                f)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   X))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X
                                Y
                                f)))
                       (@eq.{v+1}
                          (@category_theory.has_hom.hom.{v u&#x27;} D
                             (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y))
                          (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                             (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                             (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                             (@category_theory.category_struct.comp.{v u} C
                                (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   Y)))
                          (@category_theory.category_struct.comp.{v u&#x27;} D
                             (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X)
                             (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                Y)
                             (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                   (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                      (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                   (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                   X))
                             (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                   (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                   (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                X
                                Y
                                f)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      Y)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X
                                      Y
                                      f)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         X))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X
                                      Y
                                      f)))
                             (@eq.{v+1}
                                (@category_theory.has_hom.hom.{v u&#x27;} D
                                   (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                      (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                   (@category_theory.category_struct.comp.{v u} C
                                      (@category_theory.category.to_category_struct.{v u} C 𝒞)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         Y)))
                                (@category_theory.category_struct.comp.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X)
                                   (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      Y)
                                   (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                      (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                      (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                      (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                            (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                         (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                         X))
                                   (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                      (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                         (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                         (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                            (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                      X
                                      Y
                                      f))))
                          (@eq.rec.{0 v+1}
                             (@category_theory.has_hom.hom.{v u&#x27;} D
                                (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                   (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                             (@category_theory.category_struct.comp.{v u&#x27;} D
                                (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y))
                                (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.functor.map.{v v v u} J _inst_1 C 𝒞 F X Y f))
                                (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                   (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                   (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                   (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                      (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                         (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                         (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                      (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                      Y)))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v u&#x27;} D
                                  (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                     (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X))
                                  (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                     (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))),
                                @eq.{1} Prop
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           Y)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X
                                           Y
                                           f)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F Y)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              Y)))
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              X))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X
                                           Y
                                           f)))
                                  (@eq.{v+1}
                                     (@category_theory.has_hom.hom.{v u&#x27;} D
                                        (@category_theory.category_struct.to_has_hom.{v u&#x27;} D
                                           (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟))
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y))
                                     _a
                                     (@category_theory.category_struct.comp.{v u&#x27;} D
                                        (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           X)
                                        (@category_theory.functor.obj.{v v v u&#x27;} J _inst_1 D 𝒟
                                           (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} D 𝒟
                                              (@category_theory.functor.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 D 𝒟)
                                              (@category_theory.functor.obj.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)))
                                           Y)
                                        (@category_theory.functor.map.{v v u u&#x27;} C 𝒞 D 𝒟 G
                                           (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F X)
                                           (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x)
                                           (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F
                                              (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                                                 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞)
                                                 (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F _x))
                                              (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F _x)
                                              X))
                                        (@category_theory.functor.map.{v v v u&#x27;} J _inst_1 D 𝒟 (… …) X Y f))))
                             …
                             …
                             …))
                       …)))))
      …
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  end cocones</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  end limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  variables {D : Type u&#x27;} [category.{v} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u&#x27; → Type (max u&#x27; (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332  variables {F : J ⥤ C} {G : J ⥤ C} (H : C ⥤ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u) [_inst_1 : category_theory.category.{v u} C] (D : Type u&#x27;) [_inst_2 : category_theory.category.{v u&#x27;} D], Type (max v u u&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  open category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336  /-- The image of a cone in C under a functor G : C ⥤ D is a cone in D. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337  def map_cone   (c : cone F)   : cone (F ⋙ H)   := (cones.functoriality H).obj c</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.cones.functoriality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] (G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟), @category_theory.functor.{v v (max u v) (max u&#x27; v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)) (@category_theory.limits.cone.category.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C] {D : Type (max u&#x27; v)} [_inst_2 : category_theory.category.{v (max u&#x27; v)} D], @category_theory.functor.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338  /-- The image of a cocone in C under a functor G : C ⥤ D is a cocone in D. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339  def map_cocone (c : cocone F) : cocone (F ⋙ H) := (cocones.functoriality H).obj c</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.cocones.functoriality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] (G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟), @category_theory.functor.{v v (max u v) (max u&#x27; v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)) (@category_theory.limits.cocone.category.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C] {D : Type (max u&#x27; v)} [_inst_2 : category_theory.category.{v (max u&#x27; v)} D], @category_theory.functor.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  @[simp] lemma map_cone_X (c : cone F) : (H.map_cone c).X = H.obj c.X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u&#x27;} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u&#x27;}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u&#x27;} {a : α}, @eq.{u&#x27;+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342  @[simp] lemma map_cocone_X (c : cocone F) : (H.map_cocone c).X = H.obj c.X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 339, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u&#x27;} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u&#x27;}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u&#x27;} {a : α}, @eq.{u&#x27;+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The image of a cocone in C under a functor G : C ⥤ D is a cocone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  def map_cone_inv [is_equivalence H]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.is_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟 → Type (max u u&#x27; v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='A functor that is part of a (half) adjoint equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345    (c : cone (F ⋙ H)) : cone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346  let t := (inv H).map_cone c in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 D _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.inv.{v v u u&#x27;} C 𝒞 D _inst_2 H _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u&#x27; u} C 𝒞 D _inst_2), @category_theory.limits.cone.{v u&#x27;} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  let α : (F ⋙ H) ⋙ inv H ⟶ F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] {E : Type u} [ℰ : category_theory.category.{v u} E], @category_theory.functor.{v v v u&#x27;} C 𝒞 D 𝒟 → @category_theory.functor.{v v u&#x27; u} D 𝒟 E ℰ → @category_theory.functor.{v v v u} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348    ((whisker_left F (is_equivalence.unit_iso H).inv) : F ⋙ (H ⋙ inv H) ⟶ _) ≫ (functor.right_unitor _).hom in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_equivalence.unit_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.right_unitor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [c : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F (@category_theory.is_equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{(max u v) (max v u)} C] {X Y : C}, @category_theory.iso.{(max u v) (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u v) (max v u)} C (@category_theory.category_struct.to_has_hom.{(max u v) (max v u)} C (@category_theory.category.to_category_struct.{(max u v) (max v u)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u} [ℰ : category_theory.category.{v u} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u} D 𝒟 E ℰ → @category_theory.functor.{v v v u} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] {E : Type u} [ℰ : category_theory.category.{v u} E], @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟 → @category_theory.functor.{v v u&#x27; u} D 𝒟 E ℰ → @category_theory.functor.{v v u u} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.has_hom.{v (max v u)} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ), @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} A 𝒜 B ℬ B ℬ F (@category_theory.functor.id.{v₂ u₂} B ℬ)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C}, @category_theory.iso.{v (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349  { X := t.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 D _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.inv.{v v u u&#x27;} C 𝒞 D _inst_2 H _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350    π := ((category_theory.cones J C).map α).app (op t.X) t.π }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.cones'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 67, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v (max u v) (max v u) (max v u (v+1))} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v}) (@category_theory.functor.category.{v v u v+1} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (Type v) category_theory.types.{v})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {D : Type (max v u (v+1))} [_inst_2 : category_theory.category.{(max u v) (max v u (v+1))} D] (c : @category_theory.functor.{v (max u v) (max v u) (max v u (v+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u v) (max v u (v+1))} D (@category_theory.category_struct.to_has_hom.{(max u v) (max v u (v+1))} D (@category_theory.category.to_category_struct.{(max u v) (max v u (v+1))} D _inst_2)) (@category_theory.functor.obj.{v (max u v) (max v u) (max v u (v+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v (max u v) (max v u) (max v u (v+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 D _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.inv.{v v u u&#x27;} C 𝒞 D _inst_2 H _inst_3)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type (v+1)} [𝒟 : category_theory.category.{v v+1} D] {F G : @category_theory.functor.{v v u v+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v u v+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v v+1} D (@category_theory.category_struct.to_has_hom.{v v+1} D (@category_theory.category.to_category_struct.{v v+1} D 𝒟)) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v u v+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 D _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.inv.{v v u u&#x27;} C 𝒞 D _inst_2 H _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 (@category_theory.functor.comp.{v v v v u&#x27; u} J _inst_1 D _inst_2 C 𝒞 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) (@category_theory.functor.inv.{v v u u&#x27;} C 𝒞 D _inst_2 H _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Functorially associated to each functor `J ⥤ C`, we have the `C`-presheaf consisting of
cones with a given cone point.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352  @[simp] lemma map_cone_inv_X [is_equivalence H] (c : cone (F ⋙ H)) : (H.map_cone_inv c).X = (inv H).obj c.X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.is_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cone_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 344, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D], @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟 → Type (max u u&#x27; v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {E : Type u&#x27;} [ℰ : category_theory.category.{v u&#x27;} E], @category_theory.functor.{v v v u} C 𝒞 D 𝒟 → @category_theory.functor.{v v u u&#x27;} D 𝒟 E ℰ → @category_theory.functor.{v v v u&#x27;} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2) [_inst_3 : @category_theory.is_equivalence.{v v u u&#x27;} C 𝒞 D _inst_2 H], @category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H) → @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u&#x27;} [_inst_1 : category_theory.category.{v u&#x27;} C] {D : Type u} [_inst_2 : category_theory.category.{v u} D], @category_theory.functor.{v v u&#x27; u} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u&#x27;} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A functor that is part of a (half) adjoint equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354  def map_cone_morphism   {c c&#x27; : cone F}   (f : cone_morphism c c&#x27;)   :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.limits.cone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355    cone_morphism   (H.map_cone c)   (H.map_cone c&#x27;)   := (cones.functoriality H).map f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.cones.functoriality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 209, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] (G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟), @category_theory.functor.{v v (max u v) (max u&#x27; v)} (@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)) (@category_theory.limits.cone.category.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C] {D : Type (max u&#x27; v)} [_inst_2 : category_theory.category.{v (max u&#x27; v)} D] (c : @category_theory.functor.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C _inst_1)) X Y → @category_theory.has_hom.hom.{v (max u&#x27; v)} D (@category_theory.category_struct.to_has_hom.{v (max u&#x27; v)} D (@category_theory.category.to_category_struct.{v (max u&#x27; v)} D _inst_2)) (@category_theory.functor.obj.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone_morphism.{v u} J _inst_1 C 𝒞 F c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356  def map_cocone_morphism {c c&#x27; : cocone F} (f : cocone_morphism c c&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.limits.cocone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357    cocone_morphism (H.map_cocone c) (H.map_cocone c&#x27;) := (cocones.functoriality H).map f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone_morphism'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.limits.cocones.functoriality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 269, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 339, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 339, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] (G : @category_theory.functor.{v v u u&#x27;} C 𝒞 D 𝒟), @category_theory.functor.{v v (max u v) (max u&#x27; v)} (@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.category.{v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G)) (@category_theory.limits.cocone.category.{v u&#x27;} J _inst_1 D 𝒟 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D 𝒟 F G))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u v)} [_inst_1 : category_theory.category.{v (max u v)} C] {D : Type (max u&#x27; v)} [_inst_2 : category_theory.category.{v (max u&#x27; v)} D] (c : @category_theory.functor.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v (max u v)} C (@category_theory.category_struct.to_has_hom.{v (max u v)} C (@category_theory.category.to_category_struct.{v (max u v)} C _inst_1)) X Y → @category_theory.has_hom.hom.{v (max u&#x27; v)} D (@category_theory.category_struct.to_has_hom.{v (max u&#x27; v)} D (@category_theory.category.to_category_struct.{v (max u&#x27; v)} D _inst_2)) (@category_theory.functor.obj.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v (max u v) (max u&#x27; v)} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone_morphism.{v u} J _inst_1 C 𝒞 F c c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The image of a cocone in C under a functor G : C ⥤ D is a cocone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The image of a cocone in C under a functor G : C ⥤ D is a cocone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  @[simp] lemma map_cone_π (c : cone F) (j : J) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360    (map_cone H c).π.app j = H.map (c.π.app j) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 337, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u&#x27;} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} C 𝒞 (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u&#x27;} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] {F G : @category_theory.functor.{v v v u&#x27;} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u&#x27;} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)) (@category_theory.functor.obj.{v v v u&#x27;} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u&#x27;} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The image of a cone in C under a functor G : C ⥤ D is a cone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361  @[simp] lemma map_cocone_ι (c : cocone F) (j : J) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362    (map_cocone H c).ι.app j = H.map (c.ι.app j) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 339, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (H : @category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2), @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → @category_theory.limits.cocone.{v u&#x27;} J _inst_1 D _inst_2 (@category_theory.functor.comp.{v v v v u u&#x27;} J _inst_1 C 𝒞 D _inst_2 F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u&#x27;} [𝒞 : category_theory.category.{v u&#x27;} C] {F : @category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u&#x27;} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u&#x27;)} (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u&#x27; (max v u&#x27;)} C 𝒞 (@category_theory.functor.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u&#x27;} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u&#x27;} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u&#x27;} [𝒟 : category_theory.category.{v u&#x27;} D] {F G : @category_theory.functor.{v v v u&#x27;} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u&#x27;} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D 𝒟)) (@category_theory.functor.obj.{v v v u&#x27;} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u&#x27;} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v u u&#x27;} C 𝒞 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [_inst_1 : category_theory.category.{v u} C] {D : Type u&#x27;} [_inst_2 : category_theory.category.{v u&#x27;} D] (c : @category_theory.functor.{v v u u&#x27;} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C _inst_1)) X Y → @category_theory.has_hom.hom.{v u&#x27;} D (@category_theory.category_struct.to_has_hom.{v u&#x27;} D (@category_theory.category.to_category_struct.{v u&#x27;} D _inst_2)) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v v u u&#x27;} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The image of a cocone in C under a functor G : C ⥤ D is a cocone in D.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366  end category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368  namespace category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370  variables {F : J ⥤ Cᵒᵖ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372  -- Here and below we only automatically generate the `@[simp]` lemma for the `X` field,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373  -- as we can be a simpler `rfl` lemma for the components of the natural transformation by hand.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374  @[simps X] def cone_of_cocone_left_op (c : cocone F.left_op) : cone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375  { X := op c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376    π := nat_trans.right_op (c.ι ≫ (const.op_obj_unop (op c.X)).hom) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.right_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.const.op_obj_unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟))) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G) → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)))) G F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type u₁} [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] (X : opposite.{u₂+1} C), @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.obj.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.const.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@opposite.unop.{u₂+1} C X)) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞) (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) (@category_theory.functor.const.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C}, @category_theory.iso.{v (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378  @[simp] lemma cone_of_cocone_left_op_π_app (c : cocone F.left_op) (j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379    (cone_of_cocone_left_op c).π.app j = (c.ι.app (op j)).op :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cone_of_cocone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 374, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) → @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380  by { dsimp [cone_of_cocone_left_op], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cone_of_cocone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 374, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞)}, @category_theory.limits.cocone.{?l_1 ?l_2} (opposite.{?l_1+1} J) (@category_theory.category.opposite.{?l_1 ?l_1} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F) → @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c)))
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c)))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c))
       j)
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@opposite.op.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@opposite.op.{u+1} C
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@opposite.op.{u+1} C
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c))
       (@opposite.op.{u+1} C
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.category_struct.id.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@opposite.op.{u+1} C
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c)))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@opposite.unop.{u+1} C
             (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                j))
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   c))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c)
             (@opposite.op.{v+1} J j))))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             j))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          c)
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382  @[simps X] def cocone_left_op_of_cone (c : cone F) : cocone (F.left_op) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>383  { X := unop c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>384    ι := nat_trans.left_op c.π }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)))) F G → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟))) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>385  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>386  @[simp] lemma cocone_left_op_of_cone_ι_app (c : cone F) (j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>387    (cocone_left_op_of_cone c).ι.app j = (c.π.app (unop j)).unop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 382, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C}, @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y → @category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>388  by { dsimp [cocone_left_op_of_cone], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 382, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞)}, @category_theory.limits.cone.{?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞) F → @category_theory.limits.cocone.{?l_1 ?l_2} (opposite.{?l_1+1} J) (@category_theory.category.opposite.{?l_1 ?l_1} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c)))
          j))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c)))
       (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c))
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@opposite.unop.{v+1} J j)))
       (@opposite.unop.{u+1} C
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          c)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          c)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>389  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>390  @[simps X] def cocone_of_cone_left_op (c : cone F.left_op) : cocone F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>391  { X := op c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>392    ι := nat_trans.right_op ((const.op_obj_unop (op c.X)).hom ≫ c.π) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.right_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.const.op_obj_unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/const.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟))) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G) → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)))) G F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type u₁} [𝒥 : category_theory.category.{v₁ u₁} J] {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] (X : opposite.{u₂+1} C), @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.obj.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@category_theory.functor.const.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} J) (@category_theory.category.opposite.{v₁ u₁} J 𝒥) C 𝒞) (@opposite.unop.{u₂+1} C X)) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} J 𝒥 C 𝒞 (@category_theory.functor.obj.{v₂ (max u₁ v₂) u₂ (max v₁ v₂ u₁ u₂)} (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞) (@category_theory.functor.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) (@category_theory.functor.const.{v₁ v₂ u₁ u₂} J 𝒥 (opposite.{u₂+1} C) (@category_theory.category.opposite.{v₂ u₂} C 𝒞)) X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (max v u)} [_inst_1 : category_theory.category.{v (max v u)} C] {X Y : C}, @category_theory.iso.{v (max v u)} C _inst_1 X Y → @category_theory.has_hom.hom.{v (max v u)} C (@category_theory.category_struct.to_has_hom.{v (max v u)} C (@category_theory.category.to_category_struct.{v (max v u)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v u)} [c : category_theory.category_struct.{v (max v u)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Y → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) Y Z → @category_theory.has_hom.hom.{v (max v u)} obj (@category_theory.category_struct.to_has_hom.{v (max v u)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>393  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>394  @[simp] lemma cocone_of_cone_left_op_ι_app (c : cone F.left_op) (j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>395    (cocone_of_cone_left_op c).ι.app j = (c.π.app (op j)).op :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cocone_of_cone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 390, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) → @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>396  by { dsimp [cocone_of_cone_left_op], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cocone_of_cone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 390, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞)}, @category_theory.limits.cone.{?l_1 ?l_2} (opposite.{?l_1+1} J) (@category_theory.category.opposite.{?l_1 ?l_1} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F) → @category_theory.limits.cocone.{?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c)))
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c)))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c))
       j)
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@opposite.op.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@opposite.op.{u+1} C
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@opposite.op.{u+1} C
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c))
       (@opposite.op.{u+1} C
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@opposite.unop.{u+1} C
             (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                j))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞
                (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞))
                   (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞))
                   (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                      (@category_theory.category.opposite.{v u} C 𝒞))
                   (@opposite.op.{u+1} C
                      (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                         (@category_theory.category.opposite.{v v} J _inst_1)
                         C
                         𝒞
                         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                         c))))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c)
             (@opposite.op.{v+1} J j)))
       (@category_theory.category_struct.id.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@opposite.op.{u+1} C
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          c)
       (@opposite.unop.{u+1} C
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                c))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             c)
          (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>397  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>398  @[simps X] def cone_left_op_of_cocone (c : cocone F) : cone (F.left_op) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `c : cone F` is:
* an object `c.X` and
* a natural transformation `c.π : c.X ⟶ F` from the constant `c.X` functor to `F`.

`cone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>399  { X := unop c.X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞}, @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>400    π := nat_trans.left_op c.ι }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 (opposite.{u₂+1} D) (@category_theory.category.opposite.{v₂ u₂} D 𝒟)))) F G → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) D 𝒟))) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G) (@category_theory.functor.left_op.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>401  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>402  @[simp] lemma cone_left_op_of_cocone_π_app (c : cocone F) (j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='category_theory.limits.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='A `c : cocone F` is
* an object `c.X` and
* a natural transformation `c.ι : F ⟶ c.X` from `F` to the constant `c.X` functor.

`cocone F` is equivalent, via `cone.equiv` below, to `Σ X, F.cocones.obj X`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>403    (cone_left_op_of_cocone c).π.app j = (c.ι.app (unop j)).unop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.limits.cone.π'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.limits.cocone.ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 398, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category_struct.to_has_hom.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.category.to_category_struct.{v (max v u)} (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞))) F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D] {F G : @category_theory.functor.{v v v u} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v v v u} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v u} D (@category_theory.category_struct.to_has_hom.{v u} D (@category_theory.category.to_category_struct.{v u} D 𝒟)) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v v v u} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C}, @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y → @category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>404  by { dsimp [cone_left_op_of_cocone], simp }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 398, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type ?l_1} [_inst_1 : category_theory.small_category.{?l_1} J] {C : Type ?l_2} [𝒞 : category_theory.category.{?l_1 ?l_2} C] {F : @category_theory.functor.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞)}, @category_theory.limits.cocone.{?l_1 ?l_2} J _inst_1 (opposite.{?l_2+1} C) (@category_theory.category.opposite.{?l_1 ?l_2} C 𝒞) F → @category_theory.limits.cone.{?l_1 ?l_2} (opposite.{?l_1+1} J) (@category_theory.category.opposite.{?l_1 ?l_1} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{?l_1 ?l_1 ?l_1 ?l_2} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c)))
          j)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c)))
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c))
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='J : Type v,
_inst_1 : category_theory.small_category.{v} J,
C : Type u,
𝒞 : category_theory.category.{v u} C,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
c :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@opposite.unop.{u+1} C
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c))
       (@opposite.unop.{u+1} C
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@opposite.unop.{v+1} J j))))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          c)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          c)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                c))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             c)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>405  end category_theory.limits</code></pre>
</body>