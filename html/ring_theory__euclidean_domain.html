<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Mario Carneiro. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Mario Carneiro, Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import algebra.associated algebra.euclidean_domain ring_theory.ideals</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  open euclidean_domain set ideal</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  theorem span_gcd {α} [euclidean_domain α] (x y : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='euclidean_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12    span ({gcd x y} : set α) = span ({x, y} : set α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ideal.span'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='euclidean_domain.gcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ideal.span'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_insert.insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 333, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_ring.{u} α], set.{u} α → @ideal.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [_inst_1 : has_emptyc.{u_1} γ] [_inst_2 : has_insert.{u_1 u_1} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_ring.{u} α], set.{u} α → @ideal.{u} α _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [_inst_1 : has_emptyc.{u_1} γ] [_inst_2 : has_insert.{u_1 u_1} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_1} [c : has_insert.{u_1 u_1} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14    apply le_antisymm; refine span_le.1 _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15    { simp [submodule.span_span, mem_span_pair, submodule.le_def&#x27;, mem_span_singleton&#x27;],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                      </code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ ∀ (x_1 x_2 : α),
    @eq.{u_1+1} α
      (@has_mul.mul.{u_1} α
         (@mul_zero_class.to_has_mul.{u_1} α
            (@semiring.to_mul_zero_class.{u_1} α
               (@ring.to_semiring.{u_1} α
                  (@comm_ring.to_ring.{u_1} α
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
         x_2
         (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
      x_1 →
    @Exists.{u_1+1} α
      (λ (a : α),
         @Exists.{u_1+1} α
           (λ (b : α),
              @eq.{u_1+1} α
                (@has_add.add.{u_1} α
                   (@distrib.to_has_add.{u_1} α
                      (@ring.to_distrib.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                   (@has_mul.mul.{u_1} α
                      (@mul_zero_class.to_has_mul.{u_1} α
                         (@semiring.to_mul_zero_class.{u_1} α
                            (@ring.to_semiring.{u_1} α
                               (@comm_ring.to_ring.{u_1} α
                                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                      a
                      x)
                   (@has_mul.mul.{u_1} α
                      (@mul_zero_class.to_has_mul.{u_1} α
                         (@semiring.to_mul_zero_class.{u_1} α
                            (@ring.to_semiring.{u_1} α
                               (@comm_ring.to_ring.{u_1} α
                                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                      b
                      y))
                x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16      assume a b ha,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ ∀ (x_1 x_2 : α),
    @eq.{u_1+1} α
      (@has_mul.mul.{u_1} α
         (@mul_zero_class.to_has_mul.{u_1} α
            (@semiring.to_mul_zero_class.{u_1} α
               (@ring.to_semiring.{u_1} α
                  (@comm_ring.to_ring.{u_1} α
                     (@nonzero_comm_ring.to_comm_ring.{u_1} α
                        (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
         x_2
         (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
      x_1 →
    @Exists.{u_1+1} α
      (λ (a : α),
         @Exists.{u_1+1} α
           (λ (b : α),
              @eq.{u_1+1} α
                (@has_add.add.{u_1} α
                   (@distrib.to_has_add.{u_1} α
                      (@ring.to_distrib.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                   (@has_mul.mul.{u_1} α
                      (@mul_zero_class.to_has_mul.{u_1} α
                         (@semiring.to_mul_zero_class.{u_1} α
                            (@ring.to_semiring.{u_1} α
                               (@comm_ring.to_ring.{u_1} α
                                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                      a
                      x)
                   (@has_mul.mul.{u_1} α
                      (@mul_zero_class.to_has_mul.{u_1} α
                         (@semiring.to_mul_zero_class.{u_1} α
                            (@ring.to_semiring.{u_1} α
                               (@comm_ring.to_ring.{u_1} α
                                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                      b
                      y))
                x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @Exists.{u_1+1} α
    (λ (a_1 : α),
       @Exists.{u_1+1} α
         (λ (b : α),
            @eq.{u_1+1} α
              (@has_add.add.{u_1} α
                 (@distrib.to_has_add.{u_1} α
                    (@ring.to_distrib.{u_1} α
                       (@comm_ring.to_ring.{u_1} α
                          (@nonzero_comm_ring.to_comm_ring.{u_1} α
                             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    a_1
                    x)
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    b
                    y))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17      exact ⟨b * gcd_a x y, b * gcd_b x y, by rw [← ha, gcd_eq_gcd_ab x y];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='euclidean_domain.gcd_a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='euclidean_domain.gcd_b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='euclidean_domain.gcd_eq_gcd_ab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 211, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 214, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 238, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : has_mul.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@ring.to_semiring.{u_1} α (@comm_ring.to_ring.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))) b (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] (a b : α), @eq.{u_1+1} α (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@ring.to_distrib.{u_1} α (@comm_ring.to_ring.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@ring.to_semiring.{u_1} α (@comm_ring.to_ring.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))) a (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b)) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@ring.to_semiring.{u_1} α (@comm_ring.to_ring.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))) b (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extended GCD `a` value in the equation `gcd x y = x * a + y * b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extended GCD `b` value in the equation `gcd x y = x * a + y * b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @Exists.{u_1+1} α
    (λ (a_1 : α),
       @Exists.{u_1+1} α
         (λ (b : α),
            @eq.{u_1+1} α
              (@has_add.add.{u_1} α
                 (@distrib.to_has_add.{u_1} α
                    (@ring.to_distrib.{u_1} α
                       (@comm_ring.to_ring.{u_1} α
                          (@nonzero_comm_ring.to_comm_ring.{u_1} α
                             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    a_1
                    x)
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    b
                    y))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          y))
    a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          y))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          y))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@has_add.add.{u_1} α
          (@distrib.to_has_add.{u_1} α
             (@ring.to_distrib.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (@has_mul.mul.{u_1} α
             (@mul_zero_class.to_has_mul.{u_1} α
                (@semiring.to_mul_zero_class.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
             x
             (@euclidean_domain.gcd_a.{u_1} α _inst_1
                (λ (a b : α), (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) a b)
                x
                y))
          (@has_mul.mul.{u_1} α
             (@mul_zero_class.to_has_mul.{u_1} α
                (@semiring.to_mul_zero_class.{u_1} α
                   (@ring.to_semiring.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
             y
             (@euclidean_domain.gcd_b.{u_1} α _inst_1
                (λ (a b : α), (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) a b)
                x
                y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          y))
    a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18        simp [mul_add, mul_comm, mul_left_comm]⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mul_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : distrib.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) b c)) (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a b) (@has_mul.mul.{?l_1} α (@distrib.to_has_mul.{?l_1} α _inst_1) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b c)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @eq.{u_1+1} α
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_a.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          (@has_mul.mul.{u_1} α
             (@no_zero_divisors.to_has_mul.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
             b
             (@euclidean_domain.gcd_b.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))
          y))
    a'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y a b : α,
ha :
  @eq.{u_1+1} α
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@ring.to_semiring.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       b
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    a
⊢ @Exists.{u_1+1} α
    (λ (a_1 : α),
       @Exists.{u_1+1} α
         (λ (b : α),
            @eq.{u_1+1} α
              (@has_add.add.{u_1} α
                 (@distrib.to_has_add.{u_1} α
                    (@ring.to_distrib.{u_1} α
                       (@comm_ring.to_ring.{u_1} α
                          (@nonzero_comm_ring.to_comm_ring.{u_1} α
                             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    a_1
                    x)
                 (@has_mul.mul.{u_1} α
                    (@mul_zero_class.to_has_mul.{u_1} α
                       (@semiring.to_mul_zero_class.{u_1} α
                          (@ring.to_semiring.{u_1} α
                             (@comm_ring.to_ring.{u_1} α
                                (@nonzero_comm_ring.to_comm_ring.{u_1} α
                                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
                    b
                    y))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ @has_le.le.{u_1}
    (@ideal.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
    (@preorder.to_has_le.{u_1}
       (@ideal.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
       (@partial_order.to_preorder.{u_1}
          (@ideal.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@submodule.partial_order.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
    (@ideal.span.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       (@coe.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@coe_base.{u_1+1 (max (u_1+1) 1)}
                (@submodule.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                (set.{u_1} α)
                (@submodule.has_coe.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
          (@ideal.span.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
             (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
                (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)))))
    (@ideal.span.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
          (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19    { assume z ,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ @has_le.le.{u_1}
    (@ideal.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
    (@preorder.to_has_le.{u_1}
       (@ideal.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
       (@partial_order.to_preorder.{u_1}
          (@ideal.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@submodule.partial_order.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
    (@ideal.span.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       (@coe.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@coe_base.{u_1+1 (max (u_1+1) 1)}
                (@submodule.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                (set.{u_1} α)
                (@submodule.has_coe.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
          (@ideal.span.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
             (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
                (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)))))
    (@ideal.span.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
          (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@coe.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
                (@submodule.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                (set.{u_1} α)
                (@coe_base.{u_1+1 (max (u_1+1) 1)}
                   (@submodule.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                   (set.{u_1} α)
                   (@submodule.has_coe.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
             (@ideal.span.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
                (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
                   (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
                      x)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
             (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20      simp [mem_span_singleton, euclidean_domain.gcd_dvd_left, mem_span_pair,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ideal.mem_span_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='euclidean_domain.gcd_dvd_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ideal.mem_span_pair'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 152, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_ring.{?l_1} α] {x y : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (@ideal.{?l_1} α _inst_1) (@submodule.has_mem.{?l_1 ?l_1} α α (@comm_ring.to_ring.{?l_1} α _inst_1) (@ring.to_add_comm_group.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)) (@ring.to_module.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1))) x (@ideal.span.{?l_1} α _inst_1 (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) y))) (@has_dvd.dvd.{?l_1} α (@comm_semiring_has_dvd.{?l_1} α (@comm_ring.to_comm_semiring.{?l_1} α _inst_1)) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : euclidean_domain.{?l_1} α] [_inst_2 : decidable_eq.{?l_1+1} α] (a b : α), @has_dvd.dvd.{?l_1} α (@comm_semiring_has_dvd.{?l_1} α (@nonzero_comm_semiring.to_comm_semiring.{?l_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{?l_1} α (@euclidean_domain.to_nonzero_comm_ring.{?l_1} α _inst_1)))) (@euclidean_domain.gcd.{?l_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_ring.{?l_1} α] {x y z : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (@ideal.{?l_1} α _inst_1) (@submodule.has_mem.{?l_1 ?l_1} α α (@comm_ring.to_ring.{?l_1} α _inst_1) (@ring.to_add_comm_group.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)) (@ring.to_module.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1))) z (@ideal.span.{?l_1} α _inst_1 (@insert.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_insert.{?l_1} α) y (@singleton.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_emptyc.{?l_1} α) (@set.has_insert.{?l_1} α) x)))) (@Exists.{?l_1+1} α (λ (a : α), @Exists.{?l_1+1} α (λ (b : α), @eq.{?l_1+1} α (@has_add.add.{?l_1} α (@distrib.to_has_add.{?l_1} α (@ring.to_distrib.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1))) (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α (@ring.to_semiring.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)))) a x) (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α (@ring.to_semiring.{?l_1} α (@comm_ring.to_ring.{?l_1} α _inst_1)))) b y)) z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@coe.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
                (@submodule.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                (set.{u_1} α)
                (@coe_base.{u_1+1 (max (u_1+1) 1)}
                   (@submodule.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                   (set.{u_1} α)
                   (@submodule.has_coe.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
             (@ideal.span.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
                (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
                   (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
                      x)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
             (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21        @eq_comm _ _ z] {contextual := tt},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, iff (@eq.{u_1+1} α a b) (@eq.{u_1+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@coe.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
                (@submodule.{u_1 u_1} α α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                   (@ring.to_add_comm_group.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                   (@ring.to_module.{u_1} α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                (set.{u_1} α)
                (@coe_base.{u_1+1 (max (u_1+1) 1)}
                   (@submodule.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
                   (set.{u_1} α)
                   (@submodule.has_coe.{u_1 u_1} α α
                      (@comm_ring.to_ring.{u_1} α
                         (@nonzero_comm_ring.to_comm_ring.{u_1} α
                            (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                      (@ring.to_add_comm_group.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                      (@ring.to_module.{u_1} α
                         (@comm_ring.to_ring.{u_1} α
                            (@nonzero_comm_ring.to_comm_ring.{u_1} α
                               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
             (@ideal.span.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
                (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
                   (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
                      x)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@coe.{u_1+1 (max (u_1+1) 1)}
       (@submodule.{u_1 u_1} α α
          (@comm_ring.to_ring.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@ring.to_add_comm_group.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
          (@ring.to_module.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (set.{u_1} α)
       (@coe_to_lift.{u_1+1 (max (u_1+1) 1)}
          (@submodule.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
          (set.{u_1} α)
          (@coe_base.{u_1+1 (max (u_1+1) 1)}
             (@submodule.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
             (set.{u_1} α)
             (@submodule.has_coe.{u_1 u_1} α α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
                (@ring.to_add_comm_group.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
                (@ring.to_module.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
             (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z : α
⊢ ∀ (x_1 x_2 : α),
    @eq.{u_1+1} α z
      (@has_add.add.{u_1} α
         (@distrib.to_has_add.{u_1} α
            (@ring.to_distrib.{u_1} α
               (@comm_ring.to_ring.{u_1} α
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_1
            x)
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_2
            y)) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@comm_ring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
      (@has_add.add.{u_1} α
         (@distrib.to_has_add.{u_1} α
            (@ring.to_distrib.{u_1} α
               (@comm_ring.to_ring.{u_1} α
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_1
            x)
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_2
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22      assume a b h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z : α
⊢ ∀ (x_1 x_2 : α),
    @eq.{u_1+1} α z
      (@has_add.add.{u_1} α
         (@distrib.to_has_add.{u_1} α
            (@ring.to_distrib.{u_1} α
               (@comm_ring.to_ring.{u_1} α
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_1
            x)
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_2
            y)) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@comm_ring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
      (@has_add.add.{u_1} α
         (@distrib.to_has_add.{u_1} α
            (@ring.to_distrib.{u_1} α
               (@comm_ring.to_ring.{u_1} α
                  (@nonzero_comm_ring.to_comm_ring.{u_1} α
                     (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_1
            x)
         (@has_mul.mul.{u_1} α
            (@mul_zero_class.to_has_mul.{u_1} α
               (@semiring.to_mul_zero_class.{u_1} α
                  (@ring.to_semiring.{u_1} α
                     (@comm_ring.to_ring.{u_1} α
                        (@nonzero_comm_ring.to_comm_ring.{u_1} α
                           (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
            x_2
            y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z a b : α,
h :
  @eq.{u_1+1} α z
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23      exact dvd_add (dvd_mul_of_dvd_right (gcd_dvd_left _ _) _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='dvd_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='euclidean_domain.gcd_dvd_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] {a b c : α}, @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a b → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a c → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a (@has_add.add.{u_1} α (@distrib.to_has_add.{u_1} α (@semiring.to_distrib.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] (a b : α), @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z a b : α,
h :
  @eq.{u_1+1} α z
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24        (dvd_mul_of_dvd_right (gcd_dvd_right _ _) _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='dvd_mul_of_dvd_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='euclidean_domain.gcd_dvd_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] {a b : α}, @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a b → ∀ (c : α), @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] (a b : α), @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y z a b : α,
h :
  @eq.{u_1+1} α z
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@comm_ring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_add.add.{u_1} α
       (@distrib.to_has_add.{u_1} α
          (@ring.to_distrib.{u_1} α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          a
          x)
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@ring.to_semiring.{u_1} α
                   (@comm_ring.to_ring.{u_1} α
                      (@nonzero_comm_ring.to_comm_ring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          b
          y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  theorem gcd_is_unit_iff {α} [euclidean_domain α] {x y : α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='euclidean_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    is_unit (gcd x y) ↔ is_coprime x y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='euclidean_domain.gcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ideal.is_coprime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 149, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : monoid.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : euclidean_domain.{u} α] [_inst_2 : decidable_eq.{u+1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_ring.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='is unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  by rw [← span_singleton_eq_top, span_gcd, is_coprime]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ideal.span_singleton_eq_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='span_gcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ideal.is_coprime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 11, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 149, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_ring.{u_1} α] {x : α}, iff (@eq.{u_1+1} (@ideal.{u_1} α _inst_1) (@ideal.span.{u_1} α _inst_1 (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)) (@lattice.has_top.top.{u_1} (@ideal.{u_1} α _inst_1) (@submodule.lattice.has_top.{u_1 u_1} α α (@comm_ring.to_ring.{u_1} α _inst_1) (@ring.to_add_comm_group.{u_1} α (@comm_ring.to_ring.{u_1} α _inst_1)) (@ring.to_module.{u_1} α (@comm_ring.to_ring.{u_1} α _inst_1))))) (@is_unit.{u_1} α (@ring.to_monoid.{u_1} α (@comm_ring.to_ring.{u_1} α _inst_1)) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] (x y : α), @eq.{u_1+1} (@ideal.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))) (@ideal.span.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))) (@ideal.span.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)) (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : comm_ring.{?l_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ iff
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ iff
    (@eq.{u_1+1}
       (@ideal.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α)
             (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x
                y)))
       (@lattice.has_top.top.{u_1}
          (@ideal.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@submodule.lattice.has_top.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ iff
    (@eq.{u_1+1}
       (@ideal.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
       (@ideal.span.{u_1} α
          (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
          (@has_insert.insert.{u_1 u_1} α (set.{u_1} α) (@set.has_insert.{u_1} α) y
             (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)))
       (@lattice.has_top.top.{u_1}
          (@ideal.{u_1} α
             (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
          (@submodule.lattice.has_top.{u_1 u_1} α α
             (@comm_ring.to_ring.{u_1} α
                (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))
             (@ring.to_add_comm_group.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
             (@ring.to_module.{u_1} α
                (@comm_ring.to_ring.{u_1} α
                   (@nonzero_comm_ring.to_comm_ring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))))
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ iff
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α
⊢ iff
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  theorem is_coprime_of_dvd {α} [euclidean_domain α] {x y : α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='euclidean_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    (z : ¬ (x = 0 ∧ y = 0)) (H : ∀ z ∈ nonunits α, z ≠ 0 → z ∣ x → ¬ z ∣ y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nonunits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u) [_inst_1 : monoid.{u} α], set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dvd.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dvd.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    is_coprime x y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ideal.is_coprime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 149, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_ring.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)
⊢ @ideal.is_coprime.{u_1} α
    (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
    x
    y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    rw [← gcd_is_unit_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='gcd_is_unit_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] {x y : α}, iff (@is_unit.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)) (@ideal.is_coprime.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)
⊢ @ideal.is_coprime.{u_1} α
    (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
    x
    y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)
⊢ @is_unit.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    by_contra h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1504, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `by_contradiction`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_contra'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)
⊢ @is_unit.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    refine H _ h _ (gcd_dvd_left _ _) (gcd_dvd_right _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='euclidean_domain.gcd_dvd_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='euclidean_domain.gcd_dvd_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (z : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z (@nonunits.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) → @ne.{u_1+1} α z (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) z x → not (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) z y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@is_unit.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] (a b : α), @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] (a b : α), @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ @ne.{u_1+1} α
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    rwa [ne, euclidean_domain.gcd_eq_zero_iff]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='euclidean_domain.gcd_eq_zero_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] [_inst_2 : decidable_eq.{u_1+1} α] {a b : α}, iff (@eq.{u_1+1} α (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), _inst_2 a b) a b) (@has_zero.zero.{u_1} α (@zero_ne_one_class.to_has_zero.{u_1} α (@nonzero_comm_ring.to_zero_ne_one_class.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))) (and (@eq.{u_1+1} α a (@has_zero.zero.{u_1} α (@zero_ne_one_class.to_has_zero.{u_1} α (@nonzero_comm_ring.to_zero_ne_one_class.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))) (@eq.{u_1+1} α b (@has_zero.zero.{u_1} α (@zero_ne_one_class.to_has_zero.{u_1} α (@nonzero_comm_ring.to_zero_ne_one_class.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ @ne.{u_1+1} α
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ not
    (@eq.{u_1+1} α
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
       (@has_zero.zero.{u_1} α
          (@no_zero_divisors.to_has_zero.{u_1} α
             (@domain.to_no_zero_divisors.{u_1} α
                (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@zero_ne_one_class.to_has_zero.{u_1} α
                (@nonzero_comm_ring.to_zero_ne_one_class.{u_1} α
                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@zero_ne_one_class.to_has_zero.{u_1} α
                (@nonzero_comm_ring.to_zero_ne_one_class.{u_1} α
                   (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
z :
  not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))),
H :
  ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y),
h :
  not
    (@is_unit.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
       (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y))
⊢ @ne.{u_1+1} α
    (@euclidean_domain.gcd.{u_1} α _inst_1 (λ (a b : α), classical.prop_decidable (@eq.{u_1+1} α a b)) x y)
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  theorem dvd_or_coprime {α} [euclidean_domain α] (x y : α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='euclidean_domain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/euclidean_domain.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    (h : irreducible x) : x ∣ y ∨ is_coprime x y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='irreducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dvd.dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ideal.is_coprime'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/ring_theory/ideals.lean&#x27;, &#x27;line&#x27;: 149, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : monoid.{u_1} α], α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dvd.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : comm_ring.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `irreducible p` states that `p` is non-unit and only factors into units.

We explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a
monoid allows us to reuse irreducible for associated elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x
⊢ or
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    refine or_iff_not_imp_left.2 (λ h&#x27;, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='or_iff_not_imp_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a], iff (or a b) (not a → b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x
⊢ or
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
    (@ideal.is_coprime.{u_1} α
       (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ @ideal.is_coprime.{u_1} α
    (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
    x
    y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    unfreezeI, apply is_coprime_of_dvd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='is_coprime_of_dvd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : euclidean_domain.{u_1} α] {x y : α}, not (and (@eq.{u_1+1} α x (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))) (@eq.{u_1+1} α y (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))) → (∀ (z : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z (@nonunits.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) → @ne.{u_1+1} α z (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) z x → not (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) z y)) → @ideal.is_coprime.{u_1} α (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Unfreeze local instances, which allows us to revert
 instances in the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfreezeI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ @ideal.is_coprime.{u_1} α
    (@nonzero_comm_ring.to_comm_ring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))
    x
    y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))))

α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    { rintro ⟨rfl, rfl⟩, simpa using h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@irreducible.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))) (@has_zero.zero.{u_1} α (@no_zero_divisors.to_has_zero.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))))

α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ not
    (and
       (@eq.{u_1+1} α x
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
       (@eq.{u_1+1} α y
          (@has_zero.zero.{u_1} α
             (@no_zero_divisors.to_has_zero.{u_1} α
                (@domain.to_no_zero_divisors.{u_1} α
                   (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_zero.zero.{u_1} α
          (@no_zero_divisors.to_has_zero.{u_1} α
             (@domain.to_no_zero_divisors.{u_1} α
                (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))
       (@has_zero.zero.{u_1} α
          (@no_zero_divisors.to_has_zero.{u_1} α
             (@domain.to_no_zero_divisors.{u_1} α
                (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))))
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    { rintro z nu nz ⟨w, rfl⟩ dy,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
x y : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    x,
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       x
       y)
⊢ ∀ (z : α),
    @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
      (@nonunits.{u_1} α
         (@ring.to_monoid.{u_1} α
            (@domain.to_ring.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @ne.{u_1+1} α z
      (@has_zero.zero.{u_1} α
         (@no_zero_divisors.to_has_zero.{u_1} α
            (@domain.to_no_zero_divisors.{u_1} α
               (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))) →
    @has_dvd.dvd.{u_1} α
      (@comm_semiring_has_dvd.{u_1} α
         (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
            (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
               (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
      z
      x →
    not
      (@has_dvd.dvd.{u_1} α
         (@comm_semiring_has_dvd.{u_1} α
            (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
               (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                  (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
         z
         y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
y z : α,
nu :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@nonunits.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
nz :
  @ne.{u_1+1} α z
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
dy :
  @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    z
    y,
w : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@comm_semiring.to_semiring.{u_1} α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          z
          w)
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48      refine h&#x27; (dvd.trans _ dy),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dvd.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='dy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))) z w) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] {a b c : α}, @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a b → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) b c → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))) z y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
y z : α,
nu :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@nonunits.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
nz :
  @ne.{u_1+1} α z
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
dy :
  @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    z
    y,
w : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@comm_semiring.to_semiring.{u_1} α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          z
          w)
       y)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
y z : α,
nu :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@nonunits.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
nz :
  @ne.{u_1+1} α z
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
dy :
  @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    z
    y,
w : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@comm_semiring.to_semiring.{u_1} α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          z
          w)
       y)
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49      simpa using mul_dvd_mul_left z (is_unit_iff_dvd_one.1 $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='mul_dvd_mul_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_unit_iff_dvd_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] (a : α) {b c : α}, @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) b c → @has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1))) a b) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1))) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : comm_semiring.{u_1} α] {x : α}, iff (@is_unit.{u_1} α (@semiring.to_monoid.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1)) x) (@has_dvd.dvd.{u_1} α (@comm_semiring_has_dvd.{u_1} α _inst_1) x (@has_one.one.{u_1} α (@monoid.to_has_one.{u_1} α (@semiring.to_monoid.{u_1} α (@comm_semiring.to_semiring.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
y z : α,
nu :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@nonunits.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
nz :
  @ne.{u_1+1} α z
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
dy :
  @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    z
    y,
w : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@comm_semiring.to_semiring.{u_1} α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          z
          w)
       y)
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50        (of_irreducible_mul h).resolve_left nu) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='of_irreducible_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/associated.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : monoid.{u_1} α] {x y : α}, @irreducible.{u_1} α _inst_1 (@has_mul.mul.{u_1} α (@semigroup.to_has_mul.{u_1} α (@monoid.to_semigroup.{u_1} α _inst_1)) x y) → or (@is_unit.{u_1} α _inst_1 x) (@is_unit.{u_1} α _inst_1 y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@irreducible.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))) (@has_mul.mul.{u_1} α (@mul_zero_class.to_has_mul.{u_1} α (@semiring.to_mul_zero_class.{u_1} α (@comm_semiring.to_semiring.{u_1} α (@nonzero_comm_semiring.to_comm_semiring.{u_1} α (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1)))))) z w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z (@nonunits.{u_1} α (@ring.to_monoid.{u_1} α (@domain.to_ring.{u_1} α (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_1 : euclidean_domain.{u_1} α,
y z : α,
nu :
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) z
    (@nonunits.{u_1} α
       (@ring.to_monoid.{u_1} α
          (@domain.to_ring.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
nz :
  @ne.{u_1+1} α z
    (@has_zero.zero.{u_1} α
       (@no_zero_divisors.to_has_zero.{u_1} α
          (@domain.to_no_zero_divisors.{u_1} α
             (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))),
dy :
  @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    z
    y,
w : α,
h :
  @irreducible.{u_1} α
    (@ring.to_monoid.{u_1} α
       (@domain.to_ring.{u_1} α
          (@integral_domain.to_domain.{u_1} α (@euclidean_domain.integral_domain.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w),
h&#x27; :
  not
    (@has_dvd.dvd.{u_1} α
       (@comm_semiring_has_dvd.{u_1} α
          (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
             (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
       (@has_mul.mul.{u_1} α
          (@mul_zero_class.to_has_mul.{u_1} α
             (@semiring.to_mul_zero_class.{u_1} α
                (@comm_semiring.to_semiring.{u_1} α
                   (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                      (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                         (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
          z
          w)
       y)
⊢ @has_dvd.dvd.{u_1} α
    (@comm_semiring_has_dvd.{u_1} α
       (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
          (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
             (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))
    (@has_mul.mul.{u_1} α
       (@mul_zero_class.to_has_mul.{u_1} α
          (@semiring.to_mul_zero_class.{u_1} α
             (@comm_semiring.to_semiring.{u_1} α
                (@nonzero_comm_semiring.to_comm_semiring.{u_1} α
                   (@nonzero_comm_ring.to_nonzero_comm_semiring.{u_1} α
                      (@euclidean_domain.to_nonzero_comm_ring.{u_1} α _inst_1))))))
       z
       w)
    z'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font></pre>
</body>