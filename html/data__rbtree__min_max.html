<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Microsoft Corporation. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Leonardo de Moura</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import data.rbtree.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  namespace rbnode</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  variables {α : Type u} {lt : α → α → Prop}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  lemma mem_of_min_eq (lt : α → α → Prop) [is_irrefl α lt] {a : α} {t : rbnode α} : t.min = some a → mem lt a t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u), (α → α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → α → rbnode.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14     induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15     { intros, contradiction },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
a_1 : @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16     all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17       cases t_lchild; simp [rbnode.min]; intro h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18       { subst t_val, simp [mem, irrefl_of lt a] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='t_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='irrefl_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 164, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (r : α → α → Prop) [_inst_1 : is_irrefl.{u} α r] (a : α), not (r a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19       all_goals { rw [mem], simp [t_ih_lchild h] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t_ih_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ or (@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (or (and (not (lt a t_val)) (not (lt t_val a))) (@rbnode.mem.{u} α lt a t_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ or (@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (or (and (not (lt a t_val)) (not (lt t_val a))) (@rbnode.mem.{u} α lt a t_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild,
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  lemma mem_of_max_eq (lt : α → α → Prop) [is_irrefl α lt] {a : α} {t : rbnode α} : t.max = some a → mem lt a t :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='is_irrefl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type u), (α → α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → α → rbnode.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24     induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25     { intros, contradiction },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
a_1 : @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26     all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27       cases t_rchild; simp [rbnode.max]; intro h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28       { subst t_val, simp [mem, irrefl_of lt a] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='t_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='irrefl_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 164, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (r : α → α → Prop) [_inst_1 : is_irrefl.{u} α r] (a : α), not (r a a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α),
h : @eq.{u+1} α t_val a
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.leaf.{u} α)
⊢ @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29       all_goals { rw [mem], simp [t_ih_rchild h] } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t_ih_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ or (@rbnode.mem.{u} α lt a t_lchild)
    (or (and (not (lt a t_val)) (not (lt t_val a)))
       (@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ or (@rbnode.mem.{u} α lt a t_lchild)
    (or (and (not (lt a t_val)) (not (lt t_val a)))
       (@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ @rbnode.mem.{u} α lt a
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild t_val t_rchild)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : is_irrefl.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_lchild,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t_rchild
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.some.{u} α a) →
  @rbnode.mem.{u} α lt a (@rbnode.black_node.{u} α t_lchild t_val t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  variables [decidable_rel lt] [is_strict_weak_order α lt]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='decidable_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='is_strict_weak_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (α : Type u), (α → α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  lemma eq_leaf_of_min_eq_none {t : rbnode α} : t.min = none → t = leaf :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rbnode.leaf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    { intros, refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
a : @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α)
⊢ @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      cases t_lchild; simp [rbnode.min]; intro h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40      all_goals { have := t_ih_lchild h, contradiction } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='t_ih_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.none.{u} α) → @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α),
this :
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) (@rbnode.leaf.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  lemma eq_leaf_of_max_eq_none {t : rbnode α} : t.max = none → t = leaf :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rbnode.leaf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t : rbnode.{u} α
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    { intros, refl },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)

case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
a : @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.none.{u} α)
⊢ @eq.{u+1} (rbnode.{u} α) (@rbnode.leaf.{u} α) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48      cases t_rchild; simp [rbnode.max]; intro h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49      all_goals { have := t_ih_rchild h, contradiction } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='t_ih_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.none.{u} α) → @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α),
this :
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) (@rbnode.leaf.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@rbnode.leaf.{u} α),
h :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.none.{u} α)
⊢ false'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.red_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)

case rbnode.black_node
α : Type u,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_lchild (@rbnode.leaf.{u} α),
t_ih_rchild :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) t_rchild (@rbnode.leaf.{u} α)
⊢ @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
    (@option.none.{u} α) →
  @eq.{u+1} (rbnode.{u} α) (@rbnode.black_node.{u} α t_lchild t_val t_rchild) (@rbnode.leaf.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  lemma min_is_minimal {a : α} {t : rbnode α} : ∀ {lo hi}, is_searchable lt t lo hi → t.min = some a → ∀ {b}, mem lt b t → a ≈[lt] b ∨ lt a b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.is_searchable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → rbnode.{u} α → option.{u} α → option.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → α → rbnode.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    { simp [strict_weak_order.equiv], intros _ _ hs hmin b, contradiction },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (and (not (lt a b)) (not (lt b a))) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi,
hmin : @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a),
b : α
⊢ @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (and (not (lt a b)) (not (lt b a))) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      cases t_lchild; intros lo hi hs hmin b hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild) lo hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val
          t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      { simp [rbnode.min] at hmin, subst t_val,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='t_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild) lo hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val
          t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild) lo hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild) lo hi,
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) t_val t_rchild),
hmin : @eq.{u+1} α t_val a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59        simp [mem] at hmem, cases hmem with heqv hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (and (not (lt b a)) (not (lt a b))) (@rbnode.mem.{u} α lt b t_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : or (and (not (lt b a)) (not (lt a b))) (@rbnode.mem.{u} α lt b t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60        { left, exact heqv.swap },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='heqv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (lt b a)) (not (lt a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ @strict_weak_order.equiv.{u} α lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61        { have := lt_of_mem_right hs (by constructor) hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='rbnode.lt_of_mem_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {z : α}, @rbnode.mem.{u} α lt z r → lt y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ @rbnode.is_node_of.{u} α (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) ?m_1 ?m_2 t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild,
this : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62          right, assumption } },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild,
this : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.leaf.{u} α) a t_rchild) lo hi,
hmem : @rbnode.mem.{u} α lt b t_rchild,
this : lt a b
⊢ lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val
          t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63      all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val
          t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64        have hs&#x27; := hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65        cases hs, simp [rbnode.min] at hmin,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66        rw [mem] at hmem, blast_disjs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 8, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='blast_disjs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem :
  or (@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (or (and (not (lt b t_val)) (not (lt t_val b))) (@rbnode.mem.{u} α lt b t_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem :
  or (@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (or (and (not (lt b t_val)) (not (lt t_val b))) (@rbnode.mem.{u} α lt b t_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        { exact t_ih_lchild hs_hs₁ hmin hmem },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='t_ih_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs_hs₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi → @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a) → ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo (@option.some.{u} α t_val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68        { have hmm       := mem_of_min_eq lt hmin,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.mem_of_min_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (lt : α → α → Prop) [_inst_1 : is_irrefl.{u} α lt] {a : α} {t : rbnode.{u} α}, @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69          have a_lt_val  := lt_of_mem_left hs&#x27; (by constructor) hmm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.lt_of_mem_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {x : α}, @rbnode.mem.{u} α lt x l → lt x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ @rbnode.is_node_of.{u} α
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    ?m_1
    ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_val : lt a t_val
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70          have a_lt_b    := lt_of_lt_of_incomp a_lt_val hmem.swap,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='lt_of_lt_of_incomp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a_lt_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : is_strict_weak_order.{u} α lt] [_inst_2 : @decidable_rel.{u+1} α lt] {a b c : α}, lt a b → and (not (lt b c)) (not (lt c b)) → lt a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='lt a t_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (lt b t_val)) (not (lt t_val b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_val : lt a t_val
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_val : lt a t_val,
a_lt_b : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71          right, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_val : lt a t_val,
a_lt_b : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_val : lt a t_val,
a_lt_b : lt a b
⊢ lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72        { have hmm       := mem_of_min_eq lt hmin,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.mem_of_min_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (lt : α → α → Prop) [_inst_1 : is_irrefl.{u} α lt] {a : α} {t : rbnode.{u} α}, @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73          have a_lt_b    := lt_of_mem_left_right hs&#x27; (by constructor) hmm hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.lt_of_mem_left_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 159, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {x z : α}, @rbnode.mem.{u} α lt x l → @rbnode.mem.{u} α lt z r → lt x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ @rbnode.is_node_of.{u} α
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
    ?m_1
    t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_b : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74          right, assumption } } }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_b : lt a b
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hs_hs₁ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo
    (@option.some.{u} α t_val),
hs_hs₂ : @rbnode.is_searchable.{u} α lt t_rchild (@option.some.{u} α t_val) hi,
hmin :
  @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_rchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild),
a_lt_b : lt a b
⊢ lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.red_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a t_val : α,
t_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_lchild_lchild : rbnode.{u} α,
t_lchild_val : α,
t_lchild_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
    lo
    hi,
hmin :
  @eq.{u+1} (option.{u} α)
    (@rbnode.min.{u} α
       (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val
          t_rchild))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α (@rbnode.black_node.{u} α t_lchild_lchild t_lchild_val t_lchild_rchild) t_val t_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.min.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  lemma max_is_maximal {a : α} {t : rbnode α} : ∀ {lo hi}, is_searchable lt t lo hi → t.max = some a → ∀ {b}, mem lt b t → a ≈[lt] b ∨ lt b a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rbnode'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.is_searchable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → rbnode.{u} α → option.{u} α → option.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, rbnode.{u} α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → α → Prop) → α → rbnode.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    induction t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t : rbnode.{u} α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    { simp [strict_weak_order.equiv], intros _ _ hs hmax b, contradiction },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='strict_weak_order.equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 197, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {r : α → α → Prop}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (and (not (lt a b)) (not (lt b a))) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi,
hmax : @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a),
b : α
⊢ @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (and (not (lt a b)) (not (lt b a))) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      cases t_rchild; intros lo hi hs hmax b hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='rbnode.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)) lo hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val
          (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      { simp [rbnode.max] at hmax, subst t_val,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='t_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)) lo hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val
          (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)) lo hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)))
    (@option.some.{u} α a),
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.leaf
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)) lo hi,
b : α,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.leaf.{u} α)),
hmax : @eq.{u+1} α t_val a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84        simp [mem] at hmem, cases hmem with hmem heqv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='or (@rbnode.mem.{u} α lt b t_lchild) (and (not (lt b a)) (not (lt a b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : or (@rbnode.mem.{u} α lt b t_lchild) (and (not (lt b a)) (not (lt a b)))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85        { have := lt_of_mem_left hs (by constructor) hmem,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='rbnode.lt_of_mem_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {x : α}, @rbnode.mem.{u} α lt x l → lt x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b t_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ @rbnode.is_node_of.{u} α (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) t_lchild ?m_1 ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild,
this : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86          right, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild,
this : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
hmem : @rbnode.mem.{u} α lt b t_lchild,
this : lt b a
⊢ lt b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87        { left, exact heqv.swap } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='heqv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1000, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 191, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (lt b a)) (not (lt a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the first constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.leaf.{u} α) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.leaf.{u} α)) (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.leaf.{u} α) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs : @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild a (@rbnode.leaf.{u} α)) lo hi,
heqv : and (not (lt b a)) (not (lt a b))
⊢ @strict_weak_order.equiv.{u} α lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val
          (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      all_goals {</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val
          (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        have hs&#x27; := hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90        cases hs, simp [rbnode.max] at hmax,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rbnode.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, rbnode.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91        rw [mem] at hmem, blast_disjs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='rbnode.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 8, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1}, (α → α → Prop) → α → rbnode.{?l_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='blast_disjs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem :
  or (@rbnode.mem.{u} α lt b t_lchild)
    (or (and (not (lt b t_val)) (not (lt t_val b)))
       (@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)),
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem :
  or (@rbnode.mem.{u} α lt b t_lchild)
    (or (and (not (lt b t_val)) (not (lt t_val b)))
       (@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92        { have hmm       := mem_of_max_eq lt hmax,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.mem_of_max_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (lt : α → α → Prop) [_inst_1 : is_irrefl.{u} α lt] {a : α} {t : rbnode.{u} α}, @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93          have a_lt_b    := lt_of_mem_left_right hs&#x27; (by constructor) hmem hmm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.lt_of_mem_left_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 159, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {x z : α}, @rbnode.mem.{u} α lt x l → @rbnode.mem.{u} α lt z r → lt x z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b t_lchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ @rbnode.is_node_of.{u} α
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    t_lchild
    ?m_1
    (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
a_lt_b : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94          right, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
a_lt_b : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b t_lchild,
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
a_lt_b : lt b a
⊢ lt b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95        { have hmm       := mem_of_max_eq lt hmax,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.mem_of_max_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (lt : α → α → Prop) [_inst_1 : is_irrefl.{u} α lt] {a : α} {t : rbnode.{u} α}, @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t) (@option.some.{u} α a) → @rbnode.mem.{u} α lt a t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96          have val_lt_a  := lt_of_mem_right hs&#x27; (by constructor) hmm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='rbnode.lt_of_mem_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hmm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/rbtree/basic.lean&#x27;, &#x27;line&#x27;: 153, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 988, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : @decidable_rel.{u+1} α lt] [_inst_2 : is_strict_weak_order.{u} α lt] {y : α} {t l r : rbnode.{u} α} {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt t lo hi → @rbnode.is_node_of.{u} α t l y r → ∀ {z : α}, @rbnode.mem.{u} α lt z r → lt y z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) lo hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='constructor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ @rbnode.is_node_of.{u} α
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    ?m_1
    ?m_2
    (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
val_lt_a : lt t_val a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97          have a_lt_b    := lt_of_incomp_of_lt hmem val_lt_a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='lt_of_incomp_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='val_lt_a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {lt : α → α → Prop} [_inst_1 : is_strict_weak_order.{u} α lt] [_inst_2 : @decidable_rel.{u+1} α lt] {a b c : α}, and (not (lt a b)) (not (lt b a)) → lt b c → lt a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (not (lt b t_val)) (not (lt t_val b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='lt t_val a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
val_lt_a : lt t_val a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
val_lt_a : lt t_val a,
a_lt_b : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98          right, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1006, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Applies the second constructor when the type of the target is an inductive data type with two constructors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
val_lt_a : lt t_val a,
a_lt_b : lt b a
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : and (not (lt b t_val)) (not (lt t_val b)),
hmm : @rbnode.mem.{u} α lt a (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild),
val_lt_a : lt t_val a,
a_lt_b : lt b a
⊢ lt b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99        { exact t_ih_rchild hs_hs₂ hmax hmem } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='t_ih_rchild'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs_hs₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 875, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {lo hi : option.{u} α}, @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi → @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a) → ∀ {b : α}, @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) (@option.some.{u} α t_val) hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='all_goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
b : α,
hs&#x27; :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hs_hs₁ : @rbnode.is_searchable.{u} α lt t_lchild lo (@option.some.{u} α t_val),
hs_hs₂ :
  @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
    (@option.some.{u} α t_val)
    hi,
hmax :
  @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    (@option.some.{u} α a),
hmem : @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.red_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_rchild_lchild : rbnode.{u} α,
t_rchild_val : α,
t_rchild_rchild : rbnode.{u} α,
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) lo hi →
    @eq.{u+1} (option.{u} α)
      (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
lo hi : option.{u} α,
hs :
  @rbnode.is_searchable.{u} α lt
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
    lo
    hi,
hmax :
  @eq.{u+1} (option.{u} α)
    (@rbnode.max.{u} α
       (@rbnode.red_node.{u} α t_lchild t_val
          (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild)))
    (@option.some.{u} α a),
b : α,
hmem :
  @rbnode.mem.{u} α lt b
    (@rbnode.red_node.{u} α t_lchild t_val (@rbnode.black_node.{u} α t_rchild_lchild t_rchild_val t_rchild_rchild))
⊢ or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case rbnode.red_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.red_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.red_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.red_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)

case rbnode.black_node
α : Type u,
lt : α → α → Prop,
_inst_1 : @decidable_rel.{u+1} α lt,
_inst_2 : is_strict_weak_order.{u} α lt,
a : α,
t_lchild : rbnode.{u} α,
t_val : α,
t_rchild : rbnode.{u} α,
t_ih_lchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_lchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_lchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_lchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a),
t_ih_rchild :
  ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt t_rchild lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α t_rchild) (@option.some.{u} α a) →
    ∀ {b : α}, @rbnode.mem.{u} α lt b t_rchild → or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)
⊢ ∀ {lo hi : option.{u} α},
    @rbnode.is_searchable.{u} α lt (@rbnode.black_node.{u} α t_lchild t_val t_rchild) lo hi →
    @eq.{u+1} (option.{u} α) (@rbnode.max.{u} α (@rbnode.black_node.{u} α t_lchild t_val t_rchild))
      (@option.some.{u} α a) →
    ∀ {b : α},
      @rbnode.mem.{u} α lt b (@rbnode.black_node.{u} α t_lchild t_val t_rchild) →
      or (@strict_weak_order.equiv.{u} α lt a b) (lt b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  end rbnode</code></pre>
</body>